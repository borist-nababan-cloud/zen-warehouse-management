/*
 Navicat Premium Data Transfer

 Source Server         : zen-wms
 Source Server Type    : PostgreSQL
 Source Server Version : 150008 (150008)
 Source Host           : 217.21.78.155:57777
 Source Catalog        : postgres
 Source Schema         : public

 Target Server Type    : PostgreSQL
 Target Server Version : 150008 (150008)
 File Encoding         : 65001

 Date: 14/01/2026 15:41:16
*/


-- ----------------------------
-- Type structure for account_type
-- ----------------------------
DROP TYPE IF EXISTS "public"."account_type";
CREATE TYPE "public"."account_type" AS ENUM (
  'CASH',
  'BANK'
);
ALTER TYPE "public"."account_type" OWNER TO "supabase_admin";

-- ----------------------------
-- Type structure for po_status
-- ----------------------------
DROP TYPE IF EXISTS "public"."po_status";
CREATE TYPE "public"."po_status" AS ENUM (
  'DRAFT',
  'ISSUED',
  'PARTIAL',
  'COMPLETED',
  'CANCELLED',
  'PAID',
  'INVOICED'
);
ALTER TYPE "public"."po_status" OWNER TO "supabase_admin";

-- ----------------------------
-- Type structure for transaction_category_type
-- ----------------------------
DROP TYPE IF EXISTS "public"."transaction_category_type";
CREATE TYPE "public"."transaction_category_type" AS ENUM (
  'CAPITAL',
  'OTHER_INCOME',
  'REFUND',
  'EXPENSE_OPS',
  'EXPENSE_PURCHASE',
  'WITHDRAWAL',
  'PETTY_REFILL',
  'OTHERS'
);
ALTER TYPE "public"."transaction_category_type" OWNER TO "supabase_admin";

-- ----------------------------
-- Sequence structure for barang_price_history_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."barang_price_history_id_seq";
CREATE SEQUENCE "public"."barang_price_history_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for barang_prices_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."barang_prices_id_seq";
CREATE SEQUENCE "public"."barang_prices_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for barang_units_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."barang_units_id_seq";
CREATE SEQUENCE "public"."barang_units_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for group_outlet_group_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."group_outlet_group_id_seq";
CREATE SEQUENCE "public"."group_outlet_group_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 2147483647
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for locations_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."locations_id_seq";
CREATE SEQUENCE "public"."locations_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for master_barang_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."master_barang_id_seq";
CREATE SEQUENCE "public"."master_barang_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for master_type_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."master_type_id_seq";
CREATE SEQUENCE "public"."master_type_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for trans_detail_autonum_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."trans_detail_autonum_seq";
CREATE SEQUENCE "public"."trans_detail_autonum_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Table structure for barang_price_history
-- ----------------------------
DROP TABLE IF EXISTS "public"."barang_price_history";
CREATE TABLE "public"."barang_price_history" (
  "id" int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1
),
  "barang_id" int8 NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "old_price" numeric(15,2),
  "new_price" numeric(15,2),
  "price_type" text COLLATE "pg_catalog"."default",
  "changed_at" timestamptz(6) DEFAULT now(),
  "changed_by" uuid
)
;

-- ----------------------------
-- Table structure for barang_prices
-- ----------------------------
DROP TABLE IF EXISTS "public"."barang_prices";
CREATE TABLE "public"."barang_prices" (
  "barang_id" int8 NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "buy_price" numeric(15,2) DEFAULT 0,
  "sell_price" numeric(15,2) DEFAULT 0,
  "updated_at" timestamptz(6) DEFAULT now(),
  "update_by" text COLLATE "pg_catalog"."default",
  "id" int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1
)
)
;

-- ----------------------------
-- Table structure for barang_units
-- ----------------------------
DROP TABLE IF EXISTS "public"."barang_units";
CREATE TABLE "public"."barang_units" (
  "barang_id" int8 NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "base_uom" text COLLATE "pg_catalog"."default" DEFAULT 'PCS'::text,
  "purchase_uom" text COLLATE "pg_catalog"."default" DEFAULT 'PCS'::text,
  "conversion_rate" numeric(10,2) DEFAULT 1,
  "updated_at" timestamptz(6) DEFAULT now(),
  "id" int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1
),
  "update_by" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for finance_account_ledger
-- ----------------------------
DROP TABLE IF EXISTS "public"."finance_account_ledger";
CREATE TABLE "public"."finance_account_ledger" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "account_id" uuid NOT NULL,
  "transaction_type" text COLLATE "pg_catalog"."default" NOT NULL,
  "amount" numeric(15,2) NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "ref_id" uuid,
  "balance_after" numeric(15,2),
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for finance_ap_ledger
-- ----------------------------
DROP TABLE IF EXISTS "public"."finance_ap_ledger";
CREATE TABLE "public"."finance_ap_ledger" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "invoice_id" uuid NOT NULL,
  "kode_supplier" uuid,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "original_amount" numeric(15,2) NOT NULL,
  "paid_amount" numeric(15,2) DEFAULT 0,
  "remaining_balance" numeric(15,2) GENERATED ALWAYS AS (
(original_amount - paid_amount)
) STORED,
  "due_date" date NOT NULL,
  "is_paid" bool DEFAULT false,
  "created_at" timestamptz(6) DEFAULT now(),
  "ref_outlet_id" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for finance_general_transactions
-- ----------------------------
DROP TABLE IF EXISTS "public"."finance_general_transactions";
CREATE TABLE "public"."finance_general_transactions" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "financial_account_id" uuid NOT NULL,
  "transaction_type" text COLLATE "pg_catalog"."default",
  "amount" numeric(15,2) NOT NULL,
  "transaction_date" date DEFAULT CURRENT_DATE,
  "description" text COLLATE "pg_catalog"."default",
  "created_by" uuid,
  "created_at" timestamptz(6) DEFAULT now(),
  "category_id" uuid
)
;

-- ----------------------------
-- Table structure for finance_payment_allocations
-- ----------------------------
DROP TABLE IF EXISTS "public"."finance_payment_allocations";
CREATE TABLE "public"."finance_payment_allocations" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "payment_id" uuid NOT NULL,
  "invoice_id" uuid NOT NULL,
  "amount_allocated" numeric(15,2) NOT NULL,
  "discount_amount" numeric(15,2) DEFAULT 0
)
;

-- ----------------------------
-- Table structure for finance_payments_out
-- ----------------------------
DROP TABLE IF EXISTS "public"."finance_payments_out";
CREATE TABLE "public"."finance_payments_out" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "kode_supplier" uuid,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "financial_account_id" uuid NOT NULL,
  "total_amount" numeric(15,2) NOT NULL,
  "payment_date" date DEFAULT CURRENT_DATE,
  "notes" text COLLATE "pg_catalog"."default",
  "created_by" uuid,
  "created_at" timestamptz(6) DEFAULT now(),
  "ref_outlet_id" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for finance_transaction_categories
-- ----------------------------
DROP TABLE IF EXISTS "public"."finance_transaction_categories";
CREATE TABLE "public"."finance_transaction_categories" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "name" text COLLATE "pg_catalog"."default" NOT NULL,
  "type" text COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "is_active" bool DEFAULT true,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for goods_receipt_items
-- ----------------------------
DROP TABLE IF EXISTS "public"."goods_receipt_items";
CREATE TABLE "public"."goods_receipt_items" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "receipt_id" uuid NOT NULL,
  "po_item_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "qty_received" numeric(10,2) NOT NULL,
  "conversion_rate" numeric(10,2) NOT NULL,
  "qty_base_unit" numeric(15,2) GENERATED ALWAYS AS (
(qty_received * conversion_rate)
) STORED
)
;

-- ----------------------------
-- Table structure for goods_receipts
-- ----------------------------
DROP TABLE IF EXISTS "public"."goods_receipts";
CREATE TABLE "public"."goods_receipts" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "po_id" uuid NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "received_at" timestamptz(6) DEFAULT now(),
  "received_by" uuid,
  "supplier_delivery_note" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for group_outlet
-- ----------------------------
DROP TABLE IF EXISTS "public"."group_outlet";
CREATE TABLE "public"."group_outlet" (
  "group_id" int4 NOT NULL DEFAULT nextval('group_outlet_group_id_seq'::regclass),
  "created_at" timestamptz(6) DEFAULT now(),
  "group_name" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for inventory_balance
-- ----------------------------
DROP TABLE IF EXISTS "public"."inventory_balance";
CREATE TABLE "public"."inventory_balance" (
  "barang_id" int8 NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "opening_balance" numeric(15,2) DEFAULT 0,
  "qty_on_hand" numeric(15,2) DEFAULT 0,
  "last_movement_at" timestamptz(6) DEFAULT now(),
  "date_ob" date
)
;

-- ----------------------------
-- Table structure for inventory_shrinkage_logs
-- ----------------------------
DROP TABLE IF EXISTS "public"."inventory_shrinkage_logs";
CREATE TABLE "public"."inventory_shrinkage_logs" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "transaction_date" date DEFAULT CURRENT_DATE,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "barang_id" int8 NOT NULL,
  "shrinkage_category_id" uuid NOT NULL,
  "qty_lost" numeric(10,2) NOT NULL,
  "notes" text COLLATE "pg_catalog"."default",
  "created_by" uuid,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for locations
-- ----------------------------
DROP TABLE IF EXISTS "public"."locations";
CREATE TABLE "public"."locations" (
  "id" int8 NOT NULL DEFAULT nextval('locations_id_seq'::regclass),
  "name" text COLLATE "pg_catalog"."default" NOT NULL,
  "location_code" text COLLATE "pg_catalog"."default" NOT NULL,
  "location_type" text COLLATE "pg_catalog"."default" NOT NULL,
  "is_active" bool DEFAULT true,
  "created_at" timestamptz(6) DEFAULT now(),
  "updated_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for master_bank
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_bank";
CREATE TABLE "public"."master_bank" (
  "created_at" timestamptz(6) NOT NULL DEFAULT now(),
  "kode_bank" uuid NOT NULL DEFAULT gen_random_uuid(),
  "bank_name" text COLLATE "pg_catalog"."default",
  "desc" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for master_barang
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_barang";
CREATE TABLE "public"."master_barang" (
  "id" int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1
),
  "sku" text COLLATE "pg_catalog"."default" NOT NULL,
  "created_at" timestamptz(6) NOT NULL DEFAULT now(),
  "id_type" int8,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "name" text COLLATE "pg_catalog"."default",
  "deleted" bool DEFAULT false,
  "image1_url" text COLLATE "pg_catalog"."default",
  "iamge2_url" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for master_financial_accounts
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_financial_accounts";
CREATE TABLE "public"."master_financial_accounts" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "account_name" text COLLATE "pg_catalog"."default" NOT NULL,
  "account_type" "public"."account_type" NOT NULL,
  "bank_name" text COLLATE "pg_catalog"."default",
  "account_number" text COLLATE "pg_catalog"."default",
  "balance" numeric(15,2) DEFAULT 0,
  "is_active" bool DEFAULT true,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for master_outlet
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_outlet";
CREATE TABLE "public"."master_outlet" (
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "name_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "alamat" text COLLATE "pg_catalog"."default",
  "no_telp" text COLLATE "pg_catalog"."default",
  "no_wa" text COLLATE "pg_catalog"."default",
  "location" json,
  "province" text COLLATE "pg_catalog"."default",
  "outlet_group_id" int4,
  "email" text COLLATE "pg_catalog"."default",
  "active" bool DEFAULT true,
  "city" text COLLATE "pg_catalog"."default",
  "can_sto" bool DEFAULT true
)
;

-- ----------------------------
-- Table structure for master_recipe_items
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_recipe_items";
CREATE TABLE "public"."master_recipe_items" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "recipe_id" uuid NOT NULL,
  "material_barang_id" int8 NOT NULL,
  "qty_required" numeric(10,4) NOT NULL,
  "uom_usage" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for master_recipes
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_recipes";
CREATE TABLE "public"."master_recipes" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "barang_id" int8 NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL DEFAULT '111'::text,
  "description" text COLLATE "pg_catalog"."default",
  "standard_qty_output" numeric(10,2) DEFAULT 1,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for master_shrinkage_categories
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_shrinkage_categories";
CREATE TABLE "public"."master_shrinkage_categories" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "name" text COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "kode_outlet" text COLLATE "pg_catalog"."default" DEFAULT '111'::text,
  "is_active" bool DEFAULT true
)
;

-- ----------------------------
-- Table structure for master_supplier
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_supplier";
CREATE TABLE "public"."master_supplier" (
  "kode_supplier" uuid NOT NULL DEFAULT gen_random_uuid(),
  "name" text COLLATE "pg_catalog"."default",
  "address" text COLLATE "pg_catalog"."default",
  "city" text COLLATE "pg_catalog"."default",
  "phone" text COLLATE "pg_catalog"."default",
  "email" text COLLATE "pg_catalog"."default",
  "pic_name" text COLLATE "pg_catalog"."default",
  "created_at" timestamp(6) NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default",
  "kode_bank" uuid,
  "no_rekening" text COLLATE "pg_catalog"."default",
  "nama_rekening" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for master_type
-- ----------------------------
DROP TABLE IF EXISTS "public"."master_type";
CREATE TABLE "public"."master_type" (
  "id" int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1
),
  "created_at" timestamptz(6) NOT NULL DEFAULT now(),
  "nama_type" text COLLATE "pg_catalog"."default",
  "description" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for production_run_ingredients
-- ----------------------------
DROP TABLE IF EXISTS "public"."production_run_ingredients";
CREATE TABLE "public"."production_run_ingredients" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "run_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "qty_used" numeric(10,4) NOT NULL,
  "cost_per_unit" numeric(15,2) DEFAULT 0,
  "total_cost" numeric(15,2) GENERATED ALWAYS AS (
(qty_used * cost_per_unit)
) STORED
)
;

-- ----------------------------
-- Table structure for production_run_outputs
-- ----------------------------
DROP TABLE IF EXISTS "public"."production_run_outputs";
CREATE TABLE "public"."production_run_outputs" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "run_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "qty_produced" numeric(10,4) NOT NULL,
  "calculated_hpp" numeric(15,2) DEFAULT 0
)
;

-- ----------------------------
-- Table structure for production_runs
-- ----------------------------
DROP TABLE IF EXISTS "public"."production_runs";
CREATE TABLE "public"."production_runs" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "transaction_date" date DEFAULT CURRENT_DATE,
  "status" text COLLATE "pg_catalog"."default" DEFAULT 'DRAFT'::text,
  "notes" text COLLATE "pg_catalog"."default",
  "created_by" uuid,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for profiles
-- ----------------------------
DROP TABLE IF EXISTS "public"."profiles";
CREATE TABLE "public"."profiles" (
  "id" text COLLATE "pg_catalog"."default" NOT NULL,
  "email" text COLLATE "pg_catalog"."default" NOT NULL,
  "full_name" text COLLATE "pg_catalog"."default",
  "phone" text COLLATE "pg_catalog"."default",
  "role" text COLLATE "pg_catalog"."default" NOT NULL,
  "location_id" int8,
  "is_active" bool DEFAULT true,
  "created_at" timestamptz(6) DEFAULT now(),
  "updated_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for purchase_invoices
-- ----------------------------
DROP TABLE IF EXISTS "public"."purchase_invoices";
CREATE TABLE "public"."purchase_invoices" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "purchase_order_id" uuid NOT NULL,
  "supplier_invoice_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "invoice_date" date DEFAULT CURRENT_DATE,
  "payment_due_date" date,
  "total_amount" numeric(15,2) DEFAULT 0,
  "status" text COLLATE "pg_catalog"."default" DEFAULT 'UNPAID'::text,
  "created_at" timestamptz(6) DEFAULT now(),
  "created_by" uuid,
  "document_number" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for purchase_order_items
-- ----------------------------
DROP TABLE IF EXISTS "public"."purchase_order_items";
CREATE TABLE "public"."purchase_order_items" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "po_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "qty_ordered" numeric(10,2) NOT NULL,
  "uom_purchase" text COLLATE "pg_catalog"."default" NOT NULL,
  "conversion_rate" numeric(10,2) DEFAULT 1,
  "price_per_unit" numeric(15,2) NOT NULL,
  "subtotal" numeric(15,2) GENERATED ALWAYS AS (
(qty_ordered * price_per_unit)
) STORED,
  "qty_received" numeric(10,2) DEFAULT 0
)
;

-- ----------------------------
-- Table structure for purchase_orders
-- ----------------------------
DROP TABLE IF EXISTS "public"."purchase_orders";
CREATE TABLE "public"."purchase_orders" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "kode_supplier" uuid NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "created_at" timestamptz(6) DEFAULT now(),
  "issued_at" timestamptz(6),
  "expected_delivery_date" date,
  "total_amount" numeric(15,2) DEFAULT 0,
  "tax_amount" numeric(15,2) DEFAULT 0,
  "grand_total" numeric(15,2) DEFAULT 0,
  "status" "public"."po_status" DEFAULT 'DRAFT'::po_status,
  "notes" text COLLATE "pg_catalog"."default",
  "created_by" uuid
)
;

-- ----------------------------
-- Table structure for role_user
-- ----------------------------
DROP TABLE IF EXISTS "public"."role_user";
CREATE TABLE "public"."role_user" (
  "id" int4 NOT NULL,
  "role_name" text COLLATE "pg_catalog"."default" NOT NULL,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for sto_invoices
-- ----------------------------
DROP TABLE IF EXISTS "public"."sto_invoices";
CREATE TABLE "public"."sto_invoices" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "sto_id" uuid NOT NULL,
  "owe_to_outlet_id" text COLLATE "pg_catalog"."default" NOT NULL,
  "total_amount" numeric(15,2) NOT NULL,
  "due_date" date NOT NULL,
  "status" text COLLATE "pg_catalog"."default" DEFAULT 'UNPAID'::text,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for sto_items
-- ----------------------------
DROP TABLE IF EXISTS "public"."sto_items";
CREATE TABLE "public"."sto_items" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "sto_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "qty_requested" numeric(10,2) NOT NULL,
  "price_unit" numeric(15,2) NOT NULL,
  "subtotal" numeric(15,2) GENERATED ALWAYS AS (
(qty_requested * price_unit)
) STORED
)
;

-- ----------------------------
-- Table structure for sto_orders
-- ----------------------------
DROP TABLE IF EXISTS "public"."sto_orders";
CREATE TABLE "public"."sto_orders" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "from_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "to_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "sender_status" text COLLATE "pg_catalog"."default" DEFAULT 'DRAFT'::text,
  "recipient_status" text COLLATE "pg_catalog"."default" DEFAULT 'PENDING'::text,
  "shipping_cost" numeric(15,2) DEFAULT 0,
  "total_items_price" numeric(15,2) DEFAULT 0,
  "grand_total" numeric(15,2) GENERATED ALWAYS AS (
(shipping_cost + total_items_price)
) STORED,
  "created_at" timestamptz(6) DEFAULT now(),
  "created_by" uuid
)
;

-- ----------------------------
-- Table structure for sto_receipt_items
-- ----------------------------
DROP TABLE IF EXISTS "public"."sto_receipt_items";
CREATE TABLE "public"."sto_receipt_items" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "receipt_id" uuid NOT NULL,
  "sto_item_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "qty_received" numeric(10,2) NOT NULL
)
;

-- ----------------------------
-- Table structure for sto_receipts
-- ----------------------------
DROP TABLE IF EXISTS "public"."sto_receipts";
CREATE TABLE "public"."sto_receipts" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "sto_id" uuid NOT NULL,
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "received_at" timestamptz(6) DEFAULT now(),
  "received_by" uuid
)
;

-- ----------------------------
-- Table structure for sto_shipment_items
-- ----------------------------
DROP TABLE IF EXISTS "public"."sto_shipment_items";
CREATE TABLE "public"."sto_shipment_items" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "shipment_id" uuid NOT NULL,
  "sto_item_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "qty_shipped" numeric(10,2) NOT NULL
)
;

-- ----------------------------
-- Table structure for sto_shipments
-- ----------------------------
DROP TABLE IF EXISTS "public"."sto_shipments";
CREATE TABLE "public"."sto_shipments" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "sto_id" uuid NOT NULL,
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "shipped_at" timestamptz(6) DEFAULT now(),
  "shipped_by" uuid
)
;

-- ----------------------------
-- Table structure for stock_opname_headers
-- ----------------------------
DROP TABLE IF EXISTS "public"."stock_opname_headers";
CREATE TABLE "public"."stock_opname_headers" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "document_number" text COLLATE "pg_catalog"."default" NOT NULL,
  "kode_outlet" text COLLATE "pg_catalog"."default" NOT NULL,
  "opname_date" date DEFAULT CURRENT_DATE,
  "status" text COLLATE "pg_catalog"."default" DEFAULT 'DRAFT'::text,
  "notes" text COLLATE "pg_catalog"."default",
  "created_by" uuid,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Table structure for stock_opname_items
-- ----------------------------
DROP TABLE IF EXISTS "public"."stock_opname_items";
CREATE TABLE "public"."stock_opname_items" (
  "id" uuid NOT NULL DEFAULT gen_random_uuid(),
  "header_id" uuid NOT NULL,
  "barang_id" int8 NOT NULL,
  "system_qty" numeric(10,2) NOT NULL,
  "actual_qty" numeric(10,2) NOT NULL,
  "difference" numeric(10,2) GENERATED ALWAYS AS (
(actual_qty - system_qty)
) STORED,
  "notes" text COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for trans_detail
-- ----------------------------
DROP TABLE IF EXISTS "public"."trans_detail";
CREATE TABLE "public"."trans_detail" (
  "autonum" int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1
),
  "id_trans" varchar(30) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "tanggal" date NOT NULL DEFAULT '2000-01-01'::date,
  "trans_type_id" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "produk_jasa_id" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "produk_jasa_nama" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "start_time" time(6) NOT NULL DEFAULT '00:00:00'::time without time zone,
  "end_time" time(6) NOT NULL DEFAULT '00:00:00'::time without time zone,
  "harga" numeric(15,2) NOT NULL DEFAULT 0,
  "disc_amount" numeric(15,2) NOT NULL DEFAULT 0,
  "disc_percent" numeric(15,2) NOT NULL DEFAULT 0,
  "subtotal" numeric(15,2) NOT NULL DEFAULT 0,
  "teraphist_id" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "room_id" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "quantity" numeric(15,2) NOT NULL DEFAULT 0,
  "aroma" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "lama" int4 NOT NULL DEFAULT 0,
  "id_customer" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "nama_customer" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "paket" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "payment_id" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "taked" char(1) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'N'::bpchar,
  "cabang" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'SUKAJADI'::character varying,
  "kode_outlet" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying
)
;

-- ----------------------------
-- Table structure for trans_master
-- ----------------------------
DROP TABLE IF EXISTS "public"."trans_master";
CREATE TABLE "public"."trans_master" (
  "trans_id" varchar(30) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "status_trans" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'IN ORDER'::character varying,
  "tanggal" date NOT NULL DEFAULT '2000-01-01'::date,
  "start_time" time(6) NOT NULL DEFAULT '00:00:00'::time without time zone,
  "end_time" time(6) NOT NULL DEFAULT '00:00:00'::time without time zone,
  "nama_customer" varchar(255) COLLATE "pg_catalog"."default" DEFAULT '(NONE)'::character varying,
  "room_id" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "therapist_id" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "lama" int4 NOT NULL DEFAULT 0,
  "subtotal" numeric(15,2) NOT NULL DEFAULT 0,
  "paket" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(none)'::character varying,
  "notes" text COLLATE "pg_catalog"."default" DEFAULT '{}'::json,
  "id_payment" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "taked" char(1) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'N'::bpchar,
  "gender" char(1) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'M'::bpchar,
  "promo" char(1) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'N'::bpchar,
  "cabang" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'SUKAJADI'::character varying,
  "kode_outlet" varchar(50) COLLATE "pg_catalog"."default" DEFAULT '(NONE)'::character varying
)
;

-- ----------------------------
-- Table structure for trans_payment
-- ----------------------------
DROP TABLE IF EXISTS "public"."trans_payment";
CREATE TABLE "public"."trans_payment" (
  "id_payment" varchar(30) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "tanggal" date NOT NULL DEFAULT '2000-01-01'::date,
  "waktu" time(6) NOT NULL DEFAULT '00:00:00'::time without time zone,
  "id_member" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "nama_member" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "subtotal" numeric(15,2) NOT NULL DEFAULT 0,
  "disc_percent" numeric(15,2) NOT NULL DEFAULT 0,
  "disc_amount" numeric(15,2) NOT NULL DEFAULT 0,
  "total" numeric(15,2) NOT NULL DEFAULT 0,
  "pembayaran" numeric(15,2) NOT NULL DEFAULT 0,
  "kembalian" numeric(15,2) NOT NULL DEFAULT 0,
  "point_awal" numeric(15,2) NOT NULL DEFAULT 0,
  "tambah_point" numeric(15,2) NOT NULL DEFAULT 0,
  "kurang_point" numeric(15,2) NOT NULL DEFAULT 0,
  "sisa" numeric(15,2) NOT NULL DEFAULT 0,
  "payment_via" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'CASH'::character varying,
  "payment_ref" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "staff_id" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "notes" varchar(255) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "cabang" varchar(50) COLLATE "pg_catalog"."default" NOT NULL DEFAULT 'SUKAJADI'::character varying,
  "kode_outlet" varchar(50) COLLATE "pg_catalog"."default" DEFAULT '(NONE)'::character varying
)
;

-- ----------------------------
-- Table structure for trans_payment_detail
-- ----------------------------
DROP TABLE IF EXISTS "public"."trans_payment_detail";
CREATE TABLE "public"."trans_payment_detail" (
  "id_payment" varchar(30) COLLATE "pg_catalog"."default" NOT NULL DEFAULT '(NONE)'::character varying,
  "tanggal" date NOT NULL DEFAULT '2020-01-01'::date,
  "subtotal" numeric(15,2) NOT NULL DEFAULT 0,
  "kodepromo" varchar(30) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "refpromo" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "vpromo" numeric(15,2) NOT NULL DEFAULT 0,
  "refdisc" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "vdisc" numeric(15,2) NOT NULL DEFAULT 0,
  "total" numeric(15,2) NOT NULL DEFAULT 0,
  "vredeem" numeric(15,2) NOT NULL DEFAULT 0,
  "refgift" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "vgift" numeric(15,2) NOT NULL DEFAULT 0,
  "vcash" numeric(15,2) NOT NULL DEFAULT 0,
  "kodepayment1" varchar(30) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "kodebank1" varchar(30) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "refpayment1" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "vpayment1" numeric(15,2) NOT NULL DEFAULT 0,
  "kodepayment2" varchar(30) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "kodebank2" varchar(30) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "refpayment2" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "vpayment2" numeric(15,2) NOT NULL DEFAULT 0,
  "rounding" numeric(15,2) NOT NULL DEFAULT 0,
  "exchange" numeric(15,2) NOT NULL DEFAULT 0,
  "lastuser" varchar(255) COLLATE "pg_catalog"."default" DEFAULT NULL::character varying,
  "lasteditdate" timestamp(6) NOT NULL DEFAULT '2019-01-01 01:01:01'::timestamp without time zone,
  "notes" text COLLATE "pg_catalog"."default",
  "kode_outlet" varchar(50) COLLATE "pg_catalog"."default" DEFAULT '(NONE)'::character varying
)
;

-- ----------------------------
-- Table structure for users_profile
-- ----------------------------
DROP TABLE IF EXISTS "public"."users_profile";
CREATE TABLE "public"."users_profile" (
  "uid" uuid NOT NULL,
  "user_role" int4 NOT NULL DEFAULT 9,
  "kode_outlet" text COLLATE "pg_catalog"."default",
  "email" text COLLATE "pg_catalog"."default" NOT NULL,
  "created_at" timestamptz(6) DEFAULT now()
)
;

-- ----------------------------
-- Function structure for auth_get_user_outlet
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."auth_get_user_outlet"();
CREATE OR REPLACE FUNCTION "public"."auth_get_user_outlet"()
  RETURNS "pg_catalog"."text" AS $BODY$
  SELECT kode_outlet FROM public.users_profile WHERE uid = auth.uid();
$BODY$
  LANGUAGE sql STABLE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for auth_get_user_role
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."auth_get_user_role"();
CREATE OR REPLACE FUNCTION "public"."auth_get_user_role"()
  RETURNS "pg_catalog"."int4" AS $BODY$
  SELECT user_role FROM public.users_profile WHERE uid = auth.uid();
$BODY$
  LANGUAGE sql STABLE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for auto_generate_outlet_details
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."auto_generate_outlet_details"();
CREATE OR REPLACE FUNCTION "public"."auto_generate_outlet_details"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  current_user_outlet text;
BEGIN
  -- 1. Get the kode_outlet from the logged-in user's profile
  -- We use SECURITY DEFINER so this trigger has permission to read users_profile
  SELECT kode_outlet INTO current_user_outlet
  FROM public.users_profile
  WHERE uid = auth.uid();

  -- 2. Fallback Safety: 
  -- If executed by a server script (no auth.uid) or user has no outlet, 
  -- fallback to the master_barang.kode_outlet
  IF current_user_outlet IS NULL THEN
    current_user_outlet := NEW.kode_outlet;
  END IF;

  -- 3. Inventory Balance
  INSERT INTO public.inventory_balance (barang_id, kode_outlet, opening_balance, qty_on_hand)
  VALUES (NEW.id, current_user_outlet, 0, 0)
  ON CONFLICT (barang_id, kode_outlet) DO NOTHING;

  -- 4. Barang Units
  INSERT INTO public.barang_units (barang_id, kode_outlet, base_uom, conversion_rate)
  VALUES (NEW.id, current_user_outlet, 'PCS', 1)
  ON CONFLICT (barang_id, kode_outlet) DO NOTHING;

  -- 5. Barang Prices
  INSERT INTO public.barang_prices (barang_id, kode_outlet, buy_price, sell_price)
  VALUES (NEW.id, current_user_outlet, 0, 0)
  ON CONFLICT (barang_id, kode_outlet) DO NOTHING;

  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for auto_post_ap_ledger
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."auto_post_ap_ledger"();
CREATE OR REPLACE FUNCTION "public"."auto_post_ap_ledger"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  v_kode_supplier uuid;
  v_kode_outlet text;
BEGIN
  -- Fetch missing info from PO because Purchase Invoice might not have them in NEW record or to be safe
  SELECT kode_supplier, kode_outlet INTO v_kode_supplier, v_kode_outlet
  FROM public.purchase_orders
  WHERE id = NEW.purchase_order_id;
  
  -- Insert into the Ledger automatically using data from the new Invoice and fetched PO data
  INSERT INTO public.finance_ap_ledger (
      invoice_id,
      kode_supplier,
      kode_outlet,
      original_amount,
      paid_amount,
      due_date,
      is_paid
  ) VALUES (
      NEW.id,
      v_kode_supplier,
      v_kode_outlet,
      NEW.total_amount,
      0,
      NEW.payment_due_date,
      FALSE
  );

  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for auto_post_sto_ledger
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."auto_post_sto_ledger"();
CREATE OR REPLACE FUNCTION "public"."auto_post_sto_ledger"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  target_outlet text;
BEGIN
  -- Get the Outlet who OWES the money (Recipient)
  -- The Ledger stores "kode_outlet" as the DEBTOR (Who pays)
  -- And "ref_outlet_id" as the CREDITOR (Sender)
  
  -- Need to fetch the 'to_outlet' from STO to confirm who is paying
  SELECT to_outlet INTO target_outlet FROM public.sto_orders WHERE id = NEW.sto_id;

  INSERT INTO public.finance_ap_ledger (
    invoice_id,
    kode_outlet,        -- The Recipient (Me)
    ref_outlet_id,      -- The Sender (Who I owe)
    original_amount,
    paid_amount,
    due_date,
    is_paid
  ) VALUES (
    NULL, -- We might need to link this ID, but AP Ledger references purchase_invoices usually.
    -- WORKAROUND: We need to make AP Ledger flexible on invoice_id FK or create a separate linking column.
    -- For simplicity, let's assume we adjusted the FK or we leave it null for STO invoices if constraint allows.
    -- Ideally: ALTER TABLE finance_ap_ledger ADD COLUMN sto_invoice_id uuid;
    
    target_outlet,
    NEW.owe_to_outlet_id,
    NEW.total_amount,
    0,
    NEW.due_date,
    FALSE
  );
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for create_user_profile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."create_user_profile"("p_uid" uuid, "p_user_role" int4, "p_email" text, "p_kode_outlet" text);
CREATE OR REPLACE FUNCTION "public"."create_user_profile"("p_uid" uuid, "p_user_role" int4=9, "p_email" text=''::text, "p_kode_outlet" text=NULL::text)
  RETURNS SETOF "public"."users_profile" AS $BODY$
        BEGIN
          INSERT INTO public.users_profile (uid, user_role, email, kode_outlet)
          VALUES (p_uid, p_user_role, p_email, p_kode_outlet)
          ON CONFLICT (uid) DO UPDATE SET
            user_role = EXCLUDED.user_role,
            kode_outlet = EXCLUDED.kode_outlet,
            email = EXCLUDED.email;

          RETURN QUERY
            SELECT * FROM public.users_profile WHERE uid = p_uid;
        END;
        $BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100
  ROWS 1000
  SET "search_path"="public";

-- ----------------------------
-- Function structure for ensure_outlet_inventory
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."ensure_outlet_inventory"("target_barang_id" int8, "target_outlet_code" text);
CREATE OR REPLACE FUNCTION "public"."ensure_outlet_inventory"("target_barang_id" int8, "target_outlet_code" text)
  RETURNS "pg_catalog"."void" AS $BODY$
BEGIN
  -- 1. Create Inventory Slot if missing
  INSERT INTO public.inventory_balance (barang_id, kode_outlet, opening_balance, qty_on_hand)
  VALUES (target_barang_id, target_outlet_code, 0, 0)
  ON CONFLICT (barang_id, kode_outlet) DO NOTHING;

  -- 2. Create Unit Conversion (Copy from Holding/Master or Default)
  INSERT INTO public.barang_units (barang_id, kode_outlet, base_uom, conversion_rate)
  SELECT id, target_outlet_code, 'PCS', 1 -- Simplified, ideally copy from Holding's definition
  FROM public.master_barang WHERE id = target_barang_id
  ON CONFLICT (barang_id, kode_outlet) DO NOTHING;

  -- 3. Create Price (But enforce 0 or Copy Holding Price)
  -- Since they cannot change it, they might just view the Holding price, 
  -- but if you need a row for joins:
  INSERT INTO public.barang_prices (barang_id, kode_outlet, buy_price, sell_price)
  SELECT id, target_outlet_code, 0, 0 -- Start 0, or copy from source
  FROM public.master_barang WHERE id = target_barang_id
  ON CONFLICT (barang_id, kode_outlet) DO NOTHING;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_po_number
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_po_number"();
CREATE OR REPLACE FUNCTION "public"."generate_po_number"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  -- (Same variable declarations as before)
  po_prefix TEXT;
  last_po_number TEXT;
  next_sequence INT;
BEGIN
  -- CHANGE: Only generate if the Frontend sent NULL or Empty String
  IF NEW.document_number IS NOT NULL AND NEW.document_number != '' THEN
    RETURN NEW; -- Use what the user/frontend provided
  END IF;

  -- ... (Rest of the previous logic stays here: Prefix calc, Locking, Sequence calc) ...
  po_prefix := NEW.kode_outlet || '.PO.' || to_char(NOW(), 'YYYY/MM/');
  PERFORM pg_advisory_xact_lock(hashtext('purchase_orders_seq'));
  -- ... etc ...
  
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_purchase_invoice
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_purchase_invoice"("target_po_id" uuid, "supplier_inv_ref" text, "payment_due_date" date, "user_id" uuid);
CREATE OR REPLACE FUNCTION "public"."generate_purchase_invoice"("target_po_id" uuid, "supplier_inv_ref" text, "payment_due_date" date, "user_id" uuid)
  RETURNS "pg_catalog"."numeric" AS $BODY$
DECLARE
    v_total_amount numeric;
    v_po_status public.po_status;
    v_kode_supplier uuid;
    v_kode_outlet text;
    new_invoice_doc text; 
BEGIN
    -- Calculate Total from RECEIVED items (Safety Check) to ensure we invoice what we got
    SELECT COALESCE(SUM(qty_received * price_per_unit), 0)
    INTO v_total_amount
    FROM public.purchase_order_items
    WHERE po_id = target_po_id;

    -- Fetch other PO details
    SELECT status, kode_supplier, kode_outlet 
    INTO v_po_status, v_kode_supplier, v_kode_outlet
    FROM public.purchase_orders
    WHERE id = target_po_id;

    IF v_po_status IS NULL THEN
        RAISE EXCEPTION 'Purchase Order not found';
    END IF;
    
    -- Generate Document Number
    new_invoice_doc := 'INV-' || to_char(NOW(), 'YYYYMMDD') || '-' || substring(cast(target_po_id as text), 1, 4);

    -- Create Invoice Record
    INSERT INTO public.purchase_invoices (
        document_number,
        purchase_order_id,
        supplier_invoice_number,
        payment_due_date,
        total_amount,
        status,
        created_by
    ) VALUES (
        new_invoice_doc, 
        target_po_id,
        supplier_inv_ref,
        payment_due_date,
        v_total_amount,
        'UNPAID',
        user_id
    );

    -- Update PO Status to INVOICED
    UPDATE public.purchase_orders
    SET status = 'INVOICED'
    WHERE id = target_po_id;

    RETURN v_total_amount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for generate_purchase_invoice
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_purchase_invoice"("target_po_id" uuid, "supplier_inv_ref" text, "payment_due_date" date);
CREATE OR REPLACE FUNCTION "public"."generate_purchase_invoice"("target_po_id" uuid, "supplier_inv_ref" text, "payment_due_date" date)
  RETURNS "pg_catalog"."json" AS $BODY$
DECLARE
  po_record RECORD;
  calculated_total NUMERIC(15, 2);
  new_invoice_id UUID;
  new_invoice_doc TEXT;
BEGIN
  -- 1. Fetch PO details
  SELECT * INTO po_record FROM public.purchase_orders WHERE id = target_po_id;

  -- 2. Calculate Total (Safety Check)
  SELECT COALESCE(SUM(qty_received * price_per_unit), 0)
  INTO calculated_total
  FROM public.purchase_order_items
  WHERE po_id = target_po_id;

  -- 3. Create Document Number
  new_invoice_doc := 'INV-' || to_char(NOW(), 'YYYYMMDD') || '-' || substring(cast(target_po_id as text), 1, 4);

  -- 4. Insert Invoice (The Trigger will now handle the Ledger!)
  INSERT INTO public.purchase_invoices (
    document_number, 
    po_id, 
    kode_supplier, 
    kode_outlet, 
    supplier_invoice_number, 
    total_amount, 
    due_date,
    created_by,
    status
  ) VALUES (
    new_invoice_doc,
    target_po_id,
    po_record.kode_supplier,
    po_record.kode_outlet,
    supplier_inv_ref,
    calculated_total,
    payment_due_date,
    auth.uid(),
    'UNPAID'
  ) RETURNING id INTO new_invoice_id;

  -- 5. Update PO Status
  UPDATE public.purchase_orders 
  SET status = 'INVOICED' 
  WHERE id = target_po_id;

  RETURN json_build_object('invoice_id', new_invoice_id, 'total', calculated_total);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for generate_sku_trigger
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_sku_trigger"();
CREATE OR REPLACE FUNCTION "public"."generate_sku_trigger"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  new_sku TEXT;
  year_suffix TEXT;
  month_roman TEXT;
  last_sequence INT;
  seq_str TEXT;
  prefix_pattern TEXT;
BEGIN
  -- Defensive: If SKU is already set, do nothing
  IF NEW.sku IS NOT NULL AND NEW.sku <> '' THEN
    RETURN NEW;
  END IF;

  -- 1. Get Date Parts
  -- Year suffix (e.g., '25' for 2025)
  year_suffix := to_char(now(), 'YY');
  
  -- Month Roman
  SELECT get_roman_month(EXTRACT(MONTH FROM now())::INT) INTO month_roman;

  -- 2. Construct Prefix Pattern for Search
  -- Format: ZP + KODE_OUTLET + YY + ROMAN
  -- Example: ZP10925XII
  prefix_pattern := 'ZP' || NEW.kode_outlet || year_suffix || month_roman;

  -- 3. Get Last Sequence
  -- Lock ID 1001 for concurrency safety
  PERFORM pg_advisory_xact_lock(1001);

  SELECT 
    COALESCE(
      MAX(
        -- Robustly extract last 4 digits regardless of prefix length
        CAST(RIGHT(sku, 4) AS INTEGER)
      ), 
      0
    )
  INTO last_sequence
  FROM master_barang
  WHERE sku LIKE prefix_pattern || '%';

  -- 4. Generate New Sequence
  last_sequence := last_sequence + 1;
  seq_str := lpad(last_sequence::TEXT, 4, '0');

  -- 5. Construct SKU
  new_sku := prefix_pattern || seq_str;

  NEW.sku := new_sku;
  
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100
  SET "search_path"="public";

-- ----------------------------
-- Function structure for generate_sto_number
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_sto_number"();
CREATE OR REPLACE FUNCTION "public"."generate_sto_number"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  prefix TEXT;
  last_doc TEXT;
  next_seq INT;
BEGIN
  -- Format: STO.OUTLET.YYMM.
  prefix := 'STO.' || NEW.from_outlet || '.' || to_char(NOW(), 'YYMM') || '.';
  
  PERFORM pg_advisory_xact_lock(hashtext('sto_seq'));

  SELECT document_number INTO last_doc FROM public.sto_orders
  WHERE document_number LIKE prefix || '%' ORDER BY document_number DESC LIMIT 1;

  IF last_doc IS NULL THEN next_seq := 1;
  ELSE next_seq := RIGHT(last_doc, 4)::INT + 1;
  END IF;

  NEW.document_number := prefix || lpad(next_seq::text, 4, '0');
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_auth_user_profile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_auth_user_profile"();
CREATE OR REPLACE FUNCTION "public"."get_auth_user_profile"()
  RETURNS TABLE("user_role" int4, "kode_outlet" text) AS $BODY$
BEGIN
  RETURN QUERY 
  SELECT up.user_role, up.kode_outlet 
  FROM public.users_profile up 
  WHERE up.uid = auth.uid();
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100
  ROWS 1000
  SET "search_path"="public";

-- ----------------------------
-- Function structure for get_next_po_number
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_next_po_number"("outlet_code" text);
CREATE OR REPLACE FUNCTION "public"."get_next_po_number"("outlet_code" text)
  RETURNS "pg_catalog"."text" AS $BODY$
DECLARE
  po_prefix TEXT;
  last_po_number TEXT;
  next_sequence INT;
  result_number TEXT;
BEGIN
  -- 1. Build the Prefix: '111.PO.2025/02/'
  po_prefix := outlet_code || '.PO.' || to_char(NOW(), 'YYYY/MM/');

  -- 2. Find the last PO number
  SELECT document_number INTO last_po_number
  FROM public.purchase_orders
  WHERE document_number LIKE po_prefix || '%'
  ORDER BY document_number DESC
  LIMIT 1;

  -- 3. Calculate sequence
  IF last_po_number IS NULL THEN
    next_sequence := 1;
  ELSE
    next_sequence := RIGHT(last_po_number, 4)::INT + 1;
  END IF;

  -- 4. Return the formatted string
  result_number := po_prefix || lpad(next_sequence::text, 4, '0');
  RETURN result_number;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_roman_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_roman_month"("month_int" int4);
CREATE OR REPLACE FUNCTION "public"."get_roman_month"("month_int" int4)
  RETURNS "pg_catalog"."text" AS $BODY$
DECLARE
  romans TEXT[] := ARRAY['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII'];
BEGIN
  RETURN romans[month_int];
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for handle_new_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."handle_new_user"();
CREATE OR REPLACE FUNCTION "public"."handle_new_user"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
      BEGIN
        INSERT INTO public.profiles (id, email, full_name, role)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'full_name', ''),
          COALESCE(NEW.raw_user_meta_data->>'role', 'staff_holding')
        );
        RETURN NEW;
      END;
      $BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for handle_new_user_auto
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."handle_new_user_auto"();
CREATE OR REPLACE FUNCTION "public"."handle_new_user_auto"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
BEGIN
  INSERT INTO public.users_profile (uid, user_role, email, kode_outlet)
  VALUES (
    NEW.id,
    9,
    NEW.email,
    NULL
  );
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for manage_general_transaction_balance
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."manage_general_transaction_balance"();
CREATE OR REPLACE FUNCTION "public"."manage_general_transaction_balance"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
BEGIN
    -- 1. Handle MONEY IN
    IF NEW.transaction_type = 'IN' THEN
        UPDATE public.master_financial_accounts
        SET balance = balance + NEW.amount
        WHERE id = NEW.financial_account_id;
        
    -- 2. Handle MONEY OUT
    ELSIF NEW.transaction_type = 'OUT' THEN
        -- Optional: Check for insufficient funds? 
        -- For now, we allow negative balances or rely on frontend check, 
        -- but typically cash accounts shouldn't go negative.
        UPDATE public.master_financial_accounts
        SET balance = balance - NEW.amount
        WHERE id = NEW.financial_account_id;
    END IF;

    RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for process_bulk_payment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_bulk_payment"("p_outlet_id" text, "p_supplier_id" uuid, "p_account_id" uuid, "p_payment_date" date, "p_invoices" jsonb);
CREATE OR REPLACE FUNCTION "public"."process_bulk_payment"("p_outlet_id" text, "p_supplier_id" uuid, "p_account_id" uuid, "p_payment_date" date, "p_invoices" jsonb)
  RETURNS "pg_catalog"."json" AS $BODY$
DECLARE
  total_pay_amount NUMERIC := 0;
  current_balance NUMERIC;
  invoice_item JSONB;
  new_payment_id UUID;
  payment_doc_number TEXT;
BEGIN
  -- 1. Calculate Total Required
  SELECT SUM((x->>'amount')::numeric) INTO total_pay_amount
  FROM jsonb_array_elements(p_invoices) x;

  -- 2. Check Balance Availability
  SELECT balance INTO current_balance 
  FROM public.master_financial_accounts 
  WHERE id = p_account_id;

  IF current_balance < total_pay_amount THEN
    RAISE EXCEPTION 'Insufficient Funds. Balance: %, Required: %', current_balance, total_pay_amount;
  END IF;

  -- 3. Create Payment Header
  payment_doc_number := 'PAY-' || to_char(NOW(), 'YYYYMMDD-HHMI'); -- Simple ID gen
  
  INSERT INTO public.finance_payments_out (
    document_number, kode_supplier, kode_outlet, financial_account_id, total_amount, payment_date, created_by
  ) VALUES (
    payment_doc_number, p_supplier_id, p_outlet_id, p_account_id, total_pay_amount, p_payment_date, auth.uid()
  ) RETURNING id INTO new_payment_id;

  -- 4. Loop through invoices and create allocations
  FOR invoice_item IN SELECT * FROM jsonb_array_elements(p_invoices)
  LOOP
    INSERT INTO public.finance_payment_allocations (
      payment_id, invoice_id, amount_allocated
    ) VALUES (
      new_payment_id,
      (invoice_item->>'invoice_id')::uuid,
      (invoice_item->>'amount')::numeric
    );
  END LOOP;

  RETURN json_build_object('success', true, 'payment_id', new_payment_id);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for process_bulk_payment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_bulk_payment"("p_outlet_id" text, "p_supplier_id" uuid, "p_account_id" uuid, "p_payment_date" date, "p_total_amount" numeric, "p_invoices" jsonb, "p_notes" text, "p_user_id" uuid, "p_ref_outlet_id" text);
CREATE OR REPLACE FUNCTION "public"."process_bulk_payment"("p_outlet_id" text, "p_supplier_id" uuid, "p_account_id" uuid, "p_payment_date" date, "p_total_amount" numeric, "p_invoices" jsonb, "p_notes" text=NULL::text, "p_user_id" uuid=NULL::uuid, "p_ref_outlet_id" text=NULL::text)
  RETURNS "pg_catalog"."json" AS $BODY$
DECLARE
    v_account_balance numeric;
    v_payment_id uuid;
    v_inv_record jsonb;
    v_invoice_id uuid;
    v_po_id uuid;
    v_sto_id uuid; -- To store linked STO ID
    v_alloc_amount numeric; 
    v_discount_amount numeric; 
    v_total_deduction numeric; 
    v_new_doc_number text;
BEGIN
    -- 1. Check Account Balance
    SELECT balance INTO v_account_balance
    FROM public.master_financial_accounts
    WHERE id = p_account_id;

    IF v_account_balance < p_total_amount THEN
        RAISE EXCEPTION 'Insufficient funds. Balance: %, Required: %', v_account_balance, p_total_amount;
    END IF;

    -- 2. Generate Document Number
    v_new_doc_number := 'PAY-' || to_char(NOW(), 'YYYYMMDD') || '-' || substring(cast(gen_random_uuid() as text), 1, 4);

    -- 3. Insert into finance_payments_out 
    INSERT INTO public.finance_payments_out (
        document_number,
        kode_supplier,
        ref_outlet_id, -- NEW FIELD
        kode_outlet,
        financial_account_id,
        total_amount,
        payment_date,
        notes,
        created_by
    ) VALUES (
        v_new_doc_number,
        p_supplier_id, -- Can be NULL for outlet payment
        p_ref_outlet_id, -- Can be NULL for supplier payment
        p_outlet_id,
        p_account_id,
        p_total_amount, 
        p_payment_date,
        p_notes,
        p_user_id
    ) RETURNING id INTO v_payment_id;

    -- 4. Deduct Balance
    -- REMOVED: Managed by trigger "trigger_deduct_balance" on finance_payments_out
    -- UPDATE public.master_financial_accounts
    -- SET balance = balance - p_total_amount
    -- WHERE id = p_account_id;

    -- 5. Process Allocations
    FOR v_inv_record IN SELECT * FROM jsonb_array_elements(p_invoices)
    LOOP
        v_invoice_id := (v_inv_record->>'invoice_id')::uuid;
        
        v_alloc_amount := COALESCE((v_inv_record->>'amount')::numeric, 0);
        v_discount_amount := COALESCE((v_inv_record->>'discount')::numeric, 0);
        
        v_total_deduction := v_alloc_amount + v_discount_amount;

        -- A. Insert Allocation
        INSERT INTO public.finance_payment_allocations (
            payment_id,
            invoice_id,
            amount_allocated,
            discount_amount
        ) VALUES (
            v_payment_id,
            v_invoice_id,
            v_alloc_amount,
            v_discount_amount
        );

        -- B. Update AP Ledger
        UPDATE public.finance_ap_ledger
        SET 
            paid_amount = paid_amount + v_total_deduction,
            is_paid = (paid_amount + v_total_deduction >= original_amount) 
        WHERE invoice_id = v_invoice_id;

        -- C. Update Invoice Status (Handle Purchase Invoice OR STO Invoice)
        -- Try Purchase Invoice First
        UPDATE public.purchase_invoices
        SET status = CASE 
            WHEN (SELECT is_paid FROM public.finance_ap_ledger WHERE invoice_id = v_invoice_id) THEN 'PAID'
            ELSE 'PARTIAL'
        END
        WHERE id = v_invoice_id;

        -- Try STO Invoice (If exists)
        UPDATE public.sto_invoices
        SET status = CASE 
            WHEN (SELECT is_paid FROM public.finance_ap_ledger WHERE invoice_id = v_invoice_id) THEN 'PAID'
            ELSE 'UNPAID' -- STO might not have PARTIAL enum in my implementation plan, keep simple
        END
        WHERE id = v_invoice_id;

        -- D. Update Linked Order Status
        -- For PO:
        SELECT purchase_order_id INTO v_po_id FROM public.purchase_invoices WHERE id = v_invoice_id AND status = 'PAID';
        IF v_po_id IS NOT NULL THEN
            UPDATE public.purchase_orders SET status = 'PAID' WHERE id = v_po_id;
        END IF;

        -- For STO (Optional, if we want to mark STO as PAID? sto_orders table doesn't have PAID status in enum? DRAFT, ISSUED, SHIPPED, RECEIVED, COMPLETED)
        -- So we might just leave it COMPLETED.
        
    END LOOP;

    RETURN json_build_object('success', true, 'payment_id', v_payment_id);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for process_general_transaction
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_general_transaction"();
CREATE OR REPLACE FUNCTION "public"."process_general_transaction"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  balance_change numeric;
  ledger_type text;
BEGIN
  -- Determine direction
  IF NEW.transaction_type = 'IN' THEN
    balance_change := NEW.amount;
    ledger_type := 'DEPOSIT';
  ELSE
    balance_change := -NEW.amount;
    ledger_type := 'EXPENSE';
  END IF;

  -- A. Update Master Balance
  UPDATE public.master_financial_accounts
  SET balance = balance + balance_change
  WHERE id = NEW.financial_account_id;

  -- B. Create Audit Log in Ledger
  INSERT INTO public.finance_account_ledger (
    account_id,
    transaction_type,
    amount,
    description,
    ref_id,
    balance_after
  ) VALUES (
    NEW.financial_account_id,
    ledger_type,
    balance_change,
    NEW.description,
    NEW.id,
    (SELECT balance FROM public.master_financial_accounts WHERE id = NEW.financial_account_id)
  );

  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for process_production_run
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_production_run"("p_outlet_id" text, "p_date" date, "p_fg_barang_id" int8, "p_qty_produced" numeric, "p_ingredients" jsonb);
CREATE OR REPLACE FUNCTION "public"."process_production_run"("p_outlet_id" text, "p_date" date, "p_fg_barang_id" int8, "p_qty_produced" numeric, "p_ingredients" jsonb)
  RETURNS "pg_catalog"."json" AS $BODY$
DECLARE
  new_run_id uuid;
  doc_number text;
  ingredient_item jsonb;
  total_run_cost numeric := 0;
  item_cost numeric;
  calculated_unit_cost numeric;
BEGIN
  -- 1. Create Document Number
  doc_number := p_outlet_id || '.PRD.' || to_char(NOW(), 'YYYYMMDD-HHMI');

  -- 2. Insert Header
  INSERT INTO public.production_runs (
    document_number, kode_outlet, transaction_date, status, created_by
  ) VALUES (
    doc_number, p_outlet_id, p_date, 'COMPLETED', auth.uid()
  ) RETURNING id INTO new_run_id;

  -- 3. Loop Ingredients (Insert & Calc Total Cost)
  FOR ingredient_item IN SELECT * FROM jsonb_array_elements(p_ingredients)
  LOOP
    item_cost := (ingredient_item->>'cost')::numeric;
    
    -- Insert Ingredient (Trigger will deduct stock)
    INSERT INTO public.production_run_ingredients (
      run_id, barang_id, qty_used, cost_per_unit
    ) VALUES (
      new_run_id,
      (ingredient_item->>'barang_id')::bigint,
      (ingredient_item->>'qty')::numeric,
      item_cost
    );

    -- Add to total cost accumulation
    total_run_cost := total_run_cost + ((ingredient_item->>'qty')::numeric * item_cost);
  END LOOP;

  -- 4. Calculate Unit Cost for FG
  IF p_qty_produced > 0 THEN
    calculated_unit_cost := total_run_cost / p_qty_produced;
  ELSE
    calculated_unit_cost := 0;
  END IF;

  -- 5. Insert Output (Trigger will add stock & update price)
  INSERT INTO public.production_run_outputs (
    run_id, barang_id, qty_produced, calculated_hpp
  ) VALUES (
    new_run_id, p_fg_barang_id, p_qty_produced, calculated_unit_cost
  );

  RETURN json_build_object('success', true, 'run_id', new_run_id);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for process_shrinkage_deduction
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_shrinkage_deduction"();
CREATE OR REPLACE FUNCTION "public"."process_shrinkage_deduction"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
BEGIN
  -- Deduct Stock
  UPDATE public.inventory_balance
  SET qty_on_hand = qty_on_hand - NEW.qty_lost,
      last_movement_at = NOW()
  WHERE barang_id = NEW.barang_id 
    AND kode_outlet = NEW.kode_outlet;
    
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for process_sto_receipt_add
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_sto_receipt_add"();
CREATE OR REPLACE FUNCTION "public"."process_sto_receipt_add"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  recipient_outlet TEXT;
BEGIN
  -- Find Recipient Outlet
  SELECT to_outlet INTO recipient_outlet FROM public.sto_orders 
  WHERE id = (SELECT sto_id FROM public.sto_receipts WHERE id = NEW.receipt_id);

  -- Ensure Inventory Exists (Helper function from previous steps)
  PERFORM public.ensure_outlet_inventory(NEW.barang_id, recipient_outlet);

  -- Add Inventory
  UPDATE public.inventory_balance
  SET qty_on_hand = qty_on_hand + NEW.qty_received, last_movement_at = NOW()
  WHERE barang_id = NEW.barang_id AND kode_outlet = recipient_outlet;
  
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for process_sto_rejection_reversal
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_sto_rejection_reversal"();
CREATE OR REPLACE FUNCTION "public"."process_sto_rejection_reversal"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  shipment_rec RECORD;
BEGIN
  -- Only run if status changed to REJECTED and was previously SHIPPED
  IF NEW.recipient_status = 'REJECTED' AND OLD.sender_status = 'SHIPPED' THEN
    
    -- Loop through all items shipped for this STO
    FOR shipment_rec IN 
      SELECT si.barang_id, si.qty_shipped 
      FROM public.sto_shipment_items si
      JOIN public.sto_shipments s ON si.shipment_id = s.id
      WHERE s.sto_id = NEW.id
    LOOP
      -- Add Stock BACK to Sender
      UPDATE public.inventory_balance
      SET qty_on_hand = qty_on_hand + shipment_rec.qty_shipped
      WHERE barang_id = shipment_rec.barang_id AND kode_outlet = NEW.from_outlet;
    END LOOP;
    
  END IF;
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for process_sto_shipment_deduct
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_sto_shipment_deduct"();
CREATE OR REPLACE FUNCTION "public"."process_sto_shipment_deduct"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  sender_outlet TEXT;
BEGIN
  -- Find Sender Outlet from STO
  SELECT from_outlet INTO sender_outlet FROM public.sto_orders 
  WHERE id = (SELECT sto_id FROM public.sto_shipments WHERE id = NEW.shipment_id);

  -- Deduct Inventory
  UPDATE public.inventory_balance
  SET qty_on_hand = qty_on_hand - NEW.qty_shipped, last_movement_at = NOW()
  WHERE barang_id = NEW.barang_id AND kode_outlet = sender_outlet;
  
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for process_stock_opname_finalization
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."process_stock_opname_finalization"("p_header_id" uuid);
CREATE OR REPLACE FUNCTION "public"."process_stock_opname_finalization"("p_header_id" uuid)
  RETURNS "pg_catalog"."json" AS $BODY$
DECLARE
  header_rec RECORD;
  item_rec RECORD;
BEGIN
  -- A. Get Header Info
  SELECT * INTO header_rec FROM public.stock_opname_headers WHERE id = p_header_id;
  
  IF header_rec.status = 'COMPLETED' THEN
    RAISE EXCEPTION 'This Stock Opname is already completed.';
  END IF;

  -- B. Loop through items and update Inventory Balance
  FOR item_rec IN SELECT * FROM public.stock_opname_items WHERE header_id = p_header_id
  LOOP
    -- Update Qty AND Date OB
    UPDATE public.inventory_balance
    SET qty_on_hand = item_rec.actual_qty, -- Set strictly to actual
        date_ob = header_rec.opname_date,  -- Update the Opname Date
        last_movement_at = NOW()
    WHERE barang_id = item_rec.barang_id 
      AND kode_outlet = header_rec.kode_outlet;
  END LOOP;

  -- C. Mark Header as Completed
  UPDATE public.stock_opname_headers 
  SET status = 'COMPLETED' 
  WHERE id = p_header_id;

  RETURN json_build_object('success', true);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- Function structure for production_add_inventory
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."production_add_inventory"();
CREATE OR REPLACE FUNCTION "public"."production_add_inventory"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  target_outlet text;
BEGIN
  -- Get Outlet from Header
  SELECT kode_outlet INTO target_outlet FROM public.production_runs WHERE id = NEW.run_id;
  
  -- 1. Update Inventory (Add)
  UPDATE public.inventory_balance
  SET qty_on_hand = qty_on_hand + NEW.qty_produced,
      last_movement_at = NOW()
  WHERE barang_id = NEW.barang_id AND kode_outlet = target_outlet;

  -- 2. Optional: Update the "Buy Price" of this FG to match the new Production Cost
  -- This keeps your margin calculations accurate.
  UPDATE public.barang_prices
  SET buy_price = NEW.calculated_hpp,
      updated_at = NOW()
  WHERE barang_id = NEW.barang_id AND kode_outlet = target_outlet;
  
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for production_deduct_inventory
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."production_deduct_inventory"();
CREATE OR REPLACE FUNCTION "public"."production_deduct_inventory"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  target_outlet text;
BEGIN
  -- Get Outlet from Header
  SELECT kode_outlet INTO target_outlet FROM public.production_runs WHERE id = NEW.run_id;
  
  -- Update Inventory (Subtract)
  UPDATE public.inventory_balance
  SET qty_on_hand = qty_on_hand - NEW.qty_used,
      last_movement_at = NOW()
  WHERE barang_id = NEW.barang_id AND kode_outlet = target_outlet;
  
  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for update_account_balance_on_payment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."update_account_balance_on_payment"();
CREATE OR REPLACE FUNCTION "public"."update_account_balance_on_payment"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
BEGIN
  -- 1. Deduct Money from Master Account
  UPDATE public.master_financial_accounts
  SET balance = balance - NEW.total_amount
  WHERE id = NEW.financial_account_id;

  -- 2. Create Ledger Entry (Audit Trail)
  INSERT INTO public.finance_account_ledger (
    account_id,
    transaction_type,
    amount,
    description,
    ref_id,
    balance_after
  ) VALUES (
    NEW.financial_account_id,
    'PAYMENT_OUT',
    -NEW.total_amount, -- Negative because it's money out
    'Payment to Supplier ' || NEW.document_number,
    NEW.id,
    (SELECT balance FROM public.master_financial_accounts WHERE id = NEW.financial_account_id)
  );

  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for update_ap_status_on_allocation
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."update_ap_status_on_allocation"();
CREATE OR REPLACE FUNCTION "public"."update_ap_status_on_allocation"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  current_paid NUMERIC;
  total_debt NUMERIC;
BEGIN
  -- 1. Update AP Ledger (Increase Paid Amount)
  UPDATE public.finance_ap_ledger
  SET paid_amount = paid_amount + NEW.amount_allocated,
      is_paid = (paid_amount + NEW.amount_allocated) >= original_amount
  WHERE invoice_id = NEW.invoice_id;

  -- 2. Update Invoice Status
  -- Check new totals
  SELECT total_amount INTO total_debt FROM public.purchase_invoices WHERE id = NEW.invoice_id;
  SELECT paid_amount INTO current_paid FROM public.finance_ap_ledger WHERE invoice_id = NEW.invoice_id;

  UPDATE public.purchase_invoices
  SET status = CASE 
      WHEN current_paid >= total_debt THEN 'PAID'
      ELSE 'PARTIAL'
  END
  WHERE id = NEW.invoice_id;

  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for update_inventory_on_receipt
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."update_inventory_on_receipt"();
CREATE OR REPLACE FUNCTION "public"."update_inventory_on_receipt"()
  RETURNS "pg_catalog"."trigger" AS $BODY$
DECLARE
  target_outlet TEXT;
BEGIN
  -- 1. Find the Outlet Code from the Receipt Header
  SELECT kode_outlet INTO target_outlet 
  FROM public.goods_receipts 
  WHERE id = NEW.receipt_id;

  -- 2. Upsert Inventory Balance
  -- Handles case where item might not exist in that outlet yet (INSERT ... ON CONFLICT DO UPDATE)
  INSERT INTO public.inventory_balance (barang_id, kode_outlet, qty_on_hand, opening_balance, last_movement_at, date_ob)
  VALUES (NEW.barang_id, target_outlet, NEW.qty_base_unit, 0, NOW(), CURRENT_DATE)
  ON CONFLICT (barang_id, kode_outlet) DO UPDATE SET
      -- If exists, add to qty_on_hand
      qty_on_hand = inventory_balance.qty_on_hand + EXCLUDED.qty_on_hand,
      last_movement_at = NOW(),
      -- Ensure date_ob is set if it was somehow NULL
      date_ob = COALESCE(inventory_balance.date_ob, EXCLUDED.date_ob);

  -- 3. Update the Purchase Order Item (Track fulfillment)
  UPDATE public.purchase_order_items
  SET qty_received = qty_received + NEW.qty_received
  WHERE id = NEW.po_item_id;

  RETURN NEW;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE SECURITY DEFINER
  COST 100;

-- ----------------------------
-- View structure for view_financial_dashboard
-- ----------------------------
DROP VIEW IF EXISTS "public"."view_financial_dashboard";
CREATE VIEW "public"."view_financial_dashboard" AS  SELECT p.id_payment,
    p.kode_outlet,
    m.name_outlet,
    p.tanggal,
    p.waktu,
    to_char(p.tanggal::timestamp with time zone, 'Day'::text) AS day_name,
    to_char(p.tanggal::timestamp with time zone, 'Mon'::text) AS month_name,
    to_char(p.tanggal::timestamp with time zone, 'YYYY'::text) AS year_str,
    p.total AS net_revenue,
    COALESCE(pd.vcash, 0::numeric) AS amount_cash,
    COALESCE(pd.vgift, 0::numeric) AS amount_gift,
    COALESCE(pd.vdisc, 0::numeric) AS amount_discount,
    pd.kodepayment1 AS method_1,
    pd.kodebank1 AS bank_1,
    COALESCE(pd.vpayment1, 0::numeric) AS amount_1,
    pd.kodepayment2 AS method_2,
    pd.kodebank2 AS bank_2,
    COALESCE(pd.vpayment2, 0::numeric) AS amount_2,
    p.staff_id
   FROM trans_payment p
     LEFT JOIN trans_payment_detail pd ON p.id_payment::text = pd.id_payment::text
     LEFT JOIN master_outlet m ON p.kode_outlet::text = m.kode_outlet;

-- ----------------------------
-- View structure for view_peak_hours
-- ----------------------------
DROP VIEW IF EXISTS "public"."view_peak_hours";
CREATE VIEW "public"."view_peak_hours" AS  SELECT m.trans_id,
    m.kode_outlet,
    m.tanggal,
    EXTRACT(dow FROM m.tanggal)::integer AS day_index,
    TRIM(BOTH FROM to_char(m.tanggal::timestamp with time zone, 'Day'::text)) AS day_name,
    EXTRACT(hour FROM m.start_time)::integer AS hour_block,
    m.subtotal AS transaction_value
   FROM trans_master m
     JOIN master_outlet o ON m.kode_outlet::text = o.kode_outlet
  WHERE m.status_trans::text = 'PAID'::text;

-- ----------------------------
-- View structure for view_active_prices
-- ----------------------------
DROP VIEW IF EXISTS "public"."view_active_prices";
CREATE VIEW "public"."view_active_prices" AS  SELECT m.id AS barang_id,
    u.kode_outlet,
        CASE
            WHEN m.kode_outlet = '111'::text THEN p_holding.sell_price
            ELSE p_local.sell_price
        END AS final_sell_price
   FROM master_barang m
     CROSS JOIN master_outlet u
     LEFT JOIN barang_prices p_holding ON m.id = p_holding.barang_id AND p_holding.kode_outlet = '111'::text
     LEFT JOIN barang_prices p_local ON m.id = p_local.barang_id AND p_local.kode_outlet = u.kode_outlet;

-- ----------------------------
-- View structure for view_operational_dashboard
-- ----------------------------
DROP VIEW IF EXISTS "public"."view_operational_dashboard";
CREATE VIEW "public"."view_operational_dashboard" AS  SELECT m.trans_id,
    m.kode_outlet,
    o.name_outlet,
    m.tanggal,
    m.start_time,
    m.end_time,
    m.status_trans,
    m.gender,
    m.therapist_id,
    m.room_id,
    round(EXTRACT(epoch FROM m.end_time - m.start_time) / 60::numeric) AS duration_minutes,
    m.notes::jsonb ->> 'byrequest'::text AS is_by_request,
    m.notes::jsonb ->> 'typejasa'::text AS service_category,
    m.subtotal AS transaction_value
   FROM trans_master m
     LEFT JOIN master_outlet o ON m.kode_outlet::text = o.kode_outlet;

-- ----------------------------
-- View structure for view_product_mix
-- ----------------------------
DROP VIEW IF EXISTS "public"."view_product_mix";
CREATE VIEW "public"."view_product_mix" AS  SELECT d.autonum,
    d.kode_outlet,
    o.name_outlet,
    d.tanggal,
    d.trans_type_id,
    d.produk_jasa_nama,
    d.teraphist_id,
    d.quantity,
    d.harga AS unit_price,
    d.subtotal AS total_revenue
   FROM trans_detail d
     JOIN trans_master m ON d.id_trans::text = m.trans_id::text
     LEFT JOIN master_outlet o ON d.kode_outlet::text = o.kode_outlet
  WHERE m.status_trans::text = 'PAID'::text;

-- ----------------------------
-- View structure for view_promo_stats
-- ----------------------------
DROP VIEW IF EXISTS "public"."view_promo_stats";
CREATE VIEW "public"."view_promo_stats" AS  SELECT pd.id_payment,
    pd.kode_outlet,
    pd.tanggal,
    pd.kodepromo,
    pd.refpromo,
    pd.vpromo AS discount_amount
   FROM trans_payment_detail pd
  WHERE pd.kodepromo IS NOT NULL AND pd.kodepromo::text <> ''::text AND pd.vpromo > 0::numeric;

-- ----------------------------
-- View structure for view_po_details_received
-- ----------------------------
DROP VIEW IF EXISTS "public"."view_po_details_received";
CREATE VIEW "public"."view_po_details_received" AS  SELECT poi.id AS po_item_id,
    poi.po_id,
    po.kode_outlet,
    po.created_at AS po_created_at,
    po.document_number,
    b.name AS item_name,
    b.sku,
    poi.uom_purchase,
    poi.qty_ordered,
    poi.qty_received AS qty_already_received,
    poi.qty_ordered - poi.qty_received AS qty_remaining,
    poi.price_per_unit,
    poi.qty_ordered * poi.price_per_unit AS total_price_po,
    poi.qty_received * poi.price_per_unit AS total_price_received
   FROM purchase_order_items poi
     JOIN master_barang b ON poi.barang_id = b.id
     JOIN purchase_orders po ON poi.po_id = po.id;

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."barang_price_history_id_seq"
OWNED BY "public"."barang_price_history"."id";
SELECT setval('"public"."barang_price_history_id_seq"', 1, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."barang_prices_id_seq"
OWNED BY "public"."barang_prices"."id";
SELECT setval('"public"."barang_prices_id_seq"', 88, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."barang_units_id_seq"
OWNED BY "public"."barang_units"."id";
SELECT setval('"public"."barang_units_id_seq"', 88, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."group_outlet_group_id_seq"
OWNED BY "public"."group_outlet"."group_id";
SELECT setval('"public"."group_outlet_group_id_seq"', 2, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."locations_id_seq"
OWNED BY "public"."locations"."id";
SELECT setval('"public"."locations_id_seq"', 1, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."master_barang_id_seq"
OWNED BY "public"."master_barang"."id";
SELECT setval('"public"."master_barang_id_seq"', 51, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."master_type_id_seq"
OWNED BY "public"."master_type"."id";
SELECT setval('"public"."master_type_id_seq"', 5, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."trans_detail_autonum_seq"
OWNED BY "public"."trans_detail"."autonum";
SELECT setval('"public"."trans_detail_autonum_seq"', 62, true);

-- ----------------------------
-- Checks structure for table barang_price_history
-- ----------------------------
ALTER TABLE "public"."barang_price_history" ADD CONSTRAINT "barang_price_history_price_type_check" CHECK (price_type = ANY (ARRAY['BUY'::text, 'SELL'::text]));

-- ----------------------------
-- Primary Key structure for table barang_price_history
-- ----------------------------
ALTER TABLE "public"."barang_price_history" ADD CONSTRAINT "barang_price_history_pkey" PRIMARY KEY ("id", "barang_id", "kode_outlet");

-- ----------------------------
-- Uniques structure for table barang_prices
-- ----------------------------
ALTER TABLE "public"."barang_prices" ADD CONSTRAINT "barang_prices_id_key" UNIQUE ("id");
ALTER TABLE "public"."barang_prices" ADD CONSTRAINT "unique_price_per_outlet" UNIQUE ("barang_id", "kode_outlet");

-- ----------------------------
-- Uniques structure for table barang_units
-- ----------------------------
ALTER TABLE "public"."barang_units" ADD CONSTRAINT "barang_units_id_key" UNIQUE ("id");
ALTER TABLE "public"."barang_units" ADD CONSTRAINT "unique_unit_per_outlet" UNIQUE ("barang_id", "kode_outlet");

-- ----------------------------
-- Primary Key structure for table finance_account_ledger
-- ----------------------------
ALTER TABLE "public"."finance_account_ledger" ADD CONSTRAINT "account_ledger_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Checks structure for table finance_ap_ledger
-- ----------------------------
ALTER TABLE "public"."finance_ap_ledger" ADD CONSTRAINT "check_debt_owner" CHECK (kode_supplier IS NOT NULL AND ref_outlet_id IS NULL OR kode_supplier IS NULL AND ref_outlet_id IS NOT NULL);

-- ----------------------------
-- Primary Key structure for table finance_ap_ledger
-- ----------------------------
ALTER TABLE "public"."finance_ap_ledger" ADD CONSTRAINT "ap_ledger_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table finance_general_transactions
-- ----------------------------
CREATE TRIGGER "trigger_general_trans_processing" AFTER INSERT ON "public"."finance_general_transactions"
FOR EACH ROW
EXECUTE PROCEDURE "public"."manage_general_transaction_balance"();

-- ----------------------------
-- Checks structure for table finance_general_transactions
-- ----------------------------
ALTER TABLE "public"."finance_general_transactions" ADD CONSTRAINT "finance_general_transactions_transaction_type_check" CHECK (transaction_type = ANY (ARRAY['IN'::text, 'OUT'::text]));

-- ----------------------------
-- Primary Key structure for table finance_general_transactions
-- ----------------------------
ALTER TABLE "public"."finance_general_transactions" ADD CONSTRAINT "general_trans_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table finance_payment_allocations
-- ----------------------------
CREATE TRIGGER "trigger_update_ap_debt" AFTER INSERT ON "public"."finance_payment_allocations"
FOR EACH ROW
EXECUTE PROCEDURE "public"."update_ap_status_on_allocation"();

-- ----------------------------
-- Primary Key structure for table finance_payment_allocations
-- ----------------------------
ALTER TABLE "public"."finance_payment_allocations" ADD CONSTRAINT "payment_alloc_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table finance_payments_out
-- ----------------------------
CREATE TRIGGER "trigger_deduct_balance" AFTER INSERT ON "public"."finance_payments_out"
FOR EACH ROW
EXECUTE PROCEDURE "public"."update_account_balance_on_payment"();

-- ----------------------------
-- Primary Key structure for table finance_payments_out
-- ----------------------------
ALTER TABLE "public"."finance_payments_out" ADD CONSTRAINT "payments_out_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table finance_transaction_categories
-- ----------------------------
ALTER TABLE "public"."finance_transaction_categories" ADD CONSTRAINT "finance_transaction_categories_name_type_key" UNIQUE ("name", "type");

-- ----------------------------
-- Checks structure for table finance_transaction_categories
-- ----------------------------
ALTER TABLE "public"."finance_transaction_categories" ADD CONSTRAINT "finance_transaction_categories_type_check" CHECK (type = ANY (ARRAY['IN'::text, 'OUT'::text]));

-- ----------------------------
-- Primary Key structure for table finance_transaction_categories
-- ----------------------------
ALTER TABLE "public"."finance_transaction_categories" ADD CONSTRAINT "finance_transaction_categories_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table goods_receipt_items
-- ----------------------------
CREATE TRIGGER "trigger_gr_inventory" AFTER INSERT ON "public"."goods_receipt_items"
FOR EACH ROW
EXECUTE PROCEDURE "public"."update_inventory_on_receipt"();

-- ----------------------------
-- Primary Key structure for table goods_receipt_items
-- ----------------------------
ALTER TABLE "public"."goods_receipt_items" ADD CONSTRAINT "goods_receipt_items_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table goods_receipts
-- ----------------------------
ALTER TABLE "public"."goods_receipts" ADD CONSTRAINT "goods_receipts_document_number_key" UNIQUE ("document_number");

-- ----------------------------
-- Primary Key structure for table goods_receipts
-- ----------------------------
ALTER TABLE "public"."goods_receipts" ADD CONSTRAINT "goods_receipts_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table group_outlet
-- ----------------------------
ALTER TABLE "public"."group_outlet" ADD CONSTRAINT "group_outlet_pkey" PRIMARY KEY ("group_id");

-- ----------------------------
-- Uniques structure for table inventory_balance
-- ----------------------------
ALTER TABLE "public"."inventory_balance" ADD CONSTRAINT "unique_inventory_per_outlet" UNIQUE ("barang_id", "kode_outlet");

-- ----------------------------
-- Primary Key structure for table inventory_balance
-- ----------------------------
ALTER TABLE "public"."inventory_balance" ADD CONSTRAINT "inventory_balance_pkey" PRIMARY KEY ("barang_id", "kode_outlet");

-- ----------------------------
-- Triggers structure for table inventory_shrinkage_logs
-- ----------------------------
CREATE TRIGGER "trigger_shrinkage_deduct" AFTER INSERT ON "public"."inventory_shrinkage_logs"
FOR EACH ROW
EXECUTE PROCEDURE "public"."process_shrinkage_deduction"();

-- ----------------------------
-- Primary Key structure for table inventory_shrinkage_logs
-- ----------------------------
ALTER TABLE "public"."inventory_shrinkage_logs" ADD CONSTRAINT "shrink_log_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table locations
-- ----------------------------
ALTER TABLE "public"."locations" ADD CONSTRAINT "locations_location_code_key" UNIQUE ("location_code");

-- ----------------------------
-- Checks structure for table locations
-- ----------------------------
ALTER TABLE "public"."locations" ADD CONSTRAINT "locations_location_type_check" CHECK (location_type = ANY (ARRAY['holding'::text, 'outlet'::text, 'laundry'::text, 'warehouse'::text]));

-- ----------------------------
-- Primary Key structure for table locations
-- ----------------------------
ALTER TABLE "public"."locations" ADD CONSTRAINT "locations_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table master_bank
-- ----------------------------
ALTER TABLE "public"."master_bank" ADD CONSTRAINT "master_bank_pkey" PRIMARY KEY ("kode_bank");

-- ----------------------------
-- Triggers structure for table master_barang
-- ----------------------------
CREATE TRIGGER "set_sku_before_insert" BEFORE INSERT ON "public"."master_barang"
FOR EACH ROW
EXECUTE PROCEDURE "public"."generate_sku_trigger"();
CREATE TRIGGER "trigger_auto_populate_details" AFTER INSERT OR UPDATE ON "public"."master_barang"
FOR EACH ROW
EXECUTE PROCEDURE "public"."auto_generate_outlet_details"();

-- ----------------------------
-- Uniques structure for table master_barang
-- ----------------------------
ALTER TABLE "public"."master_barang" ADD CONSTRAINT "master_barang_id_key" UNIQUE ("id");
ALTER TABLE "public"."master_barang" ADD CONSTRAINT "master_barang_sku_key" UNIQUE ("sku");

-- ----------------------------
-- Primary Key structure for table master_barang
-- ----------------------------
ALTER TABLE "public"."master_barang" ADD CONSTRAINT "master_barang_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table master_financial_accounts
-- ----------------------------
ALTER TABLE "public"."master_financial_accounts" ADD CONSTRAINT "financial_accounts_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table master_outlet
-- ----------------------------
ALTER TABLE "public"."master_outlet" ADD CONSTRAINT "master_outlet_pkey" PRIMARY KEY ("kode_outlet");

-- ----------------------------
-- Primary Key structure for table master_recipe_items
-- ----------------------------
ALTER TABLE "public"."master_recipe_items" ADD CONSTRAINT "recipe_items_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table master_recipes
-- ----------------------------
ALTER TABLE "public"."master_recipes" ADD CONSTRAINT "unique_recipe_per_outlet" UNIQUE ("barang_id", "kode_outlet");

-- ----------------------------
-- Primary Key structure for table master_recipes
-- ----------------------------
ALTER TABLE "public"."master_recipes" ADD CONSTRAINT "master_recipes_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table master_shrinkage_categories
-- ----------------------------
ALTER TABLE "public"."master_shrinkage_categories" ADD CONSTRAINT "shrink_cat_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table master_supplier
-- ----------------------------
ALTER TABLE "public"."master_supplier" ADD CONSTRAINT "master_supplier_pkey" PRIMARY KEY ("kode_supplier");

-- ----------------------------
-- Primary Key structure for table master_type
-- ----------------------------
ALTER TABLE "public"."master_type" ADD CONSTRAINT "master_type_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table production_run_ingredients
-- ----------------------------
CREATE TRIGGER "trigger_production_deduct" AFTER INSERT ON "public"."production_run_ingredients"
FOR EACH ROW
EXECUTE PROCEDURE "public"."production_deduct_inventory"();

-- ----------------------------
-- Primary Key structure for table production_run_ingredients
-- ----------------------------
ALTER TABLE "public"."production_run_ingredients" ADD CONSTRAINT "prod_ing_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table production_run_outputs
-- ----------------------------
CREATE TRIGGER "trigger_production_add" AFTER INSERT ON "public"."production_run_outputs"
FOR EACH ROW
EXECUTE PROCEDURE "public"."production_add_inventory"();

-- ----------------------------
-- Primary Key structure for table production_run_outputs
-- ----------------------------
ALTER TABLE "public"."production_run_outputs" ADD CONSTRAINT "prod_out_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Checks structure for table production_runs
-- ----------------------------
ALTER TABLE "public"."production_runs" ADD CONSTRAINT "production_runs_status_check" CHECK (status = ANY (ARRAY['DRAFT'::text, 'COMPLETED'::text, 'CANCELLED'::text]));

-- ----------------------------
-- Primary Key structure for table production_runs
-- ----------------------------
ALTER TABLE "public"."production_runs" ADD CONSTRAINT "production_runs_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table profiles
-- ----------------------------
ALTER TABLE "public"."profiles" ADD CONSTRAINT "profiles_email_key" UNIQUE ("email");

-- ----------------------------
-- Checks structure for table profiles
-- ----------------------------
ALTER TABLE "public"."profiles" ADD CONSTRAINT "profiles_role_check" CHECK (role = ANY (ARRAY['admin_holding'::text, 'staff_holding'::text, 'laundry_staff'::text, 'laundry_admin'::text, 'finance'::text, 'outlet_admin'::text, 'warehouse_staff'::text]));

-- ----------------------------
-- Primary Key structure for table profiles
-- ----------------------------
ALTER TABLE "public"."profiles" ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table purchase_invoices
-- ----------------------------
CREATE TRIGGER "trigger_create_ledger_entry" AFTER INSERT ON "public"."purchase_invoices"
FOR EACH ROW
EXECUTE PROCEDURE "public"."auto_post_ap_ledger"();

-- ----------------------------
-- Uniques structure for table purchase_invoices
-- ----------------------------
ALTER TABLE "public"."purchase_invoices" ADD CONSTRAINT "purchase_invoices_document_number_key" UNIQUE ("document_number");

-- ----------------------------
-- Primary Key structure for table purchase_invoices
-- ----------------------------
ALTER TABLE "public"."purchase_invoices" ADD CONSTRAINT "purchase_invoices_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table purchase_order_items
-- ----------------------------
ALTER TABLE "public"."purchase_order_items" ADD CONSTRAINT "purchase_order_items_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table purchase_orders
-- ----------------------------
CREATE TRIGGER "trigger_auto_po_number" BEFORE INSERT ON "public"."purchase_orders"
FOR EACH ROW
EXECUTE PROCEDURE "public"."generate_po_number"();

-- ----------------------------
-- Uniques structure for table purchase_orders
-- ----------------------------
ALTER TABLE "public"."purchase_orders" ADD CONSTRAINT "purchase_orders_document_number_key" UNIQUE ("document_number");

-- ----------------------------
-- Primary Key structure for table purchase_orders
-- ----------------------------
ALTER TABLE "public"."purchase_orders" ADD CONSTRAINT "purchase_orders_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table role_user
-- ----------------------------
ALTER TABLE "public"."role_user" ADD CONSTRAINT "role_user_role_name_key" UNIQUE ("role_name");

-- ----------------------------
-- Primary Key structure for table role_user
-- ----------------------------
ALTER TABLE "public"."role_user" ADD CONSTRAINT "role_user_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table sto_invoices
-- ----------------------------
ALTER TABLE "public"."sto_invoices" ADD CONSTRAINT "sto_inv_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table sto_items
-- ----------------------------
ALTER TABLE "public"."sto_items" ADD CONSTRAINT "sto_items_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table sto_orders
-- ----------------------------
CREATE TRIGGER "trigger_sto_number" BEFORE INSERT ON "public"."sto_orders"
FOR EACH ROW
EXECUTE PROCEDURE "public"."generate_sto_number"();
CREATE TRIGGER "trigger_sto_rejection" AFTER UPDATE ON "public"."sto_orders"
FOR EACH ROW
EXECUTE PROCEDURE "public"."process_sto_rejection_reversal"();

-- ----------------------------
-- Uniques structure for table sto_orders
-- ----------------------------
ALTER TABLE "public"."sto_orders" ADD CONSTRAINT "sto_orders_document_number_key" UNIQUE ("document_number");

-- ----------------------------
-- Checks structure for table sto_orders
-- ----------------------------
ALTER TABLE "public"."sto_orders" ADD CONSTRAINT "sto_orders_recipient_status_check" CHECK (recipient_status = ANY (ARRAY['PENDING'::text, 'ACCEPTED'::text, 'REJECTED'::text, 'COMPLETED'::text]));
ALTER TABLE "public"."sto_orders" ADD CONSTRAINT "sto_orders_sender_status_check" CHECK (sender_status = ANY (ARRAY['DRAFT'::text, 'ISSUED'::text, 'SHIPPED'::text]));

-- ----------------------------
-- Primary Key structure for table sto_orders
-- ----------------------------
ALTER TABLE "public"."sto_orders" ADD CONSTRAINT "sto_orders_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table sto_receipt_items
-- ----------------------------
CREATE TRIGGER "trigger_sto_receipt_add" AFTER INSERT ON "public"."sto_receipt_items"
FOR EACH ROW
EXECUTE PROCEDURE "public"."process_sto_receipt_add"();

-- ----------------------------
-- Primary Key structure for table sto_receipt_items
-- ----------------------------
ALTER TABLE "public"."sto_receipt_items" ADD CONSTRAINT "sto_receipt_items_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table sto_receipts
-- ----------------------------
ALTER TABLE "public"."sto_receipts" ADD CONSTRAINT "sto_receipts_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Triggers structure for table sto_shipment_items
-- ----------------------------
CREATE TRIGGER "trigger_sto_shipment_deduct" AFTER INSERT ON "public"."sto_shipment_items"
FOR EACH ROW
EXECUTE PROCEDURE "public"."process_sto_shipment_deduct"();

-- ----------------------------
-- Primary Key structure for table sto_shipment_items
-- ----------------------------
ALTER TABLE "public"."sto_shipment_items" ADD CONSTRAINT "sto_ship_items_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table sto_shipments
-- ----------------------------
ALTER TABLE "public"."sto_shipments" ADD CONSTRAINT "sto_shipments_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Checks structure for table stock_opname_headers
-- ----------------------------
ALTER TABLE "public"."stock_opname_headers" ADD CONSTRAINT "stock_opname_headers_status_check" CHECK (status = ANY (ARRAY['DRAFT'::text, 'COMPLETED'::text]));

-- ----------------------------
-- Primary Key structure for table stock_opname_headers
-- ----------------------------
ALTER TABLE "public"."stock_opname_headers" ADD CONSTRAINT "so_header_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table stock_opname_items
-- ----------------------------
ALTER TABLE "public"."stock_opname_items" ADD CONSTRAINT "so_items_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table trans_detail
-- ----------------------------
CREATE INDEX "idx_td_id" ON "public"."trans_detail" USING btree (
  "id_trans" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idx_td_payment" ON "public"."trans_detail" USING btree (
  "payment_id" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idx_td_tanggal" ON "public"."trans_detail" USING btree (
  "tanggal" "pg_catalog"."date_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table trans_detail
-- ----------------------------
ALTER TABLE "public"."trans_detail" ADD CONSTRAINT "trans_detail_pkey" PRIMARY KEY ("autonum", "kode_outlet");

-- ----------------------------
-- Indexes structure for table trans_master
-- ----------------------------
CREATE INDEX "idx_tm_payment" ON "public"."trans_master" USING btree (
  "id_payment" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idx_tm_room" ON "public"."trans_master" USING btree (
  "room_id" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idx_tm_tanggal" ON "public"."trans_master" USING btree (
  "tanggal" "pg_catalog"."date_ops" ASC NULLS LAST
);
CREATE INDEX "idx_tm_therapist" ON "public"."trans_master" USING btree (
  "therapist_id" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table trans_master
-- ----------------------------
ALTER TABLE "public"."trans_master" ADD CONSTRAINT "trans_master_pkey" PRIMARY KEY ("trans_id");

-- ----------------------------
-- Indexes structure for table trans_payment
-- ----------------------------
CREATE INDEX "idx_tp_idmember" ON "public"."trans_payment" USING btree (
  "id_member" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idx_tp_nama_member" ON "public"."trans_payment" USING btree (
  "nama_member" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idx_tp_tanggal" ON "public"."trans_payment" USING btree (
  "tanggal" "pg_catalog"."date_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table trans_payment
-- ----------------------------
ALTER TABLE "public"."trans_payment" ADD CONSTRAINT "trans_payment_pkey" PRIMARY KEY ("id_payment");

-- ----------------------------
-- Indexes structure for table trans_payment_detail
-- ----------------------------
CREATE INDEX "idxkodepayment1" ON "public"."trans_payment_detail" USING btree (
  "kodepayment1" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idxkodepayment2" ON "public"."trans_payment_detail" USING btree (
  "kodepayment2" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "idxkodepromo" ON "public"."trans_payment_detail" USING btree (
  "kodepromo" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table trans_payment_detail
-- ----------------------------
ALTER TABLE "public"."trans_payment_detail" ADD CONSTRAINT "trans_payment_detail_pkey" PRIMARY KEY ("id_payment");

-- ----------------------------
-- Primary Key structure for table users_profile
-- ----------------------------
ALTER TABLE "public"."users_profile" ADD CONSTRAINT "users_profile_pkey" PRIMARY KEY ("uid");

-- ----------------------------
-- Foreign Keys structure for table barang_price_history
-- ----------------------------
ALTER TABLE "public"."barang_price_history" ADD CONSTRAINT "barang_price_history_barang_id_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."barang_price_history" ADD CONSTRAINT "barang_price_history_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table barang_prices
-- ----------------------------
ALTER TABLE "public"."barang_prices" ADD CONSTRAINT "barang_prices_barang_id_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."barang_prices" ADD CONSTRAINT "barang_prices_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table barang_units
-- ----------------------------
ALTER TABLE "public"."barang_units" ADD CONSTRAINT "barang_units_barang_id_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."barang_units" ADD CONSTRAINT "barang_units_kode_outlet_fkey1" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table finance_account_ledger
-- ----------------------------
ALTER TABLE "public"."finance_account_ledger" ADD CONSTRAINT "account_ledger_acc_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."master_financial_accounts" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table finance_ap_ledger
-- ----------------------------
ALTER TABLE "public"."finance_ap_ledger" ADD CONSTRAINT "finance_ap_ledger_ref_outlet_id_fkey" FOREIGN KEY ("ref_outlet_id") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."finance_ap_ledger" ADD CONSTRAINT "fk_ap_ledger_supplier" FOREIGN KEY ("kode_supplier") REFERENCES "public"."master_supplier" ("kode_supplier") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table finance_general_transactions
-- ----------------------------
ALTER TABLE "public"."finance_general_transactions" ADD CONSTRAINT "finance_general_transactions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."finance_general_transactions" ADD CONSTRAINT "fk_transaction_category" FOREIGN KEY ("category_id") REFERENCES "public"."finance_transaction_categories" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."finance_general_transactions" ADD CONSTRAINT "general_trans_acc_fkey" FOREIGN KEY ("financial_account_id") REFERENCES "public"."master_financial_accounts" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."finance_general_transactions" ADD CONSTRAINT "general_trans_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table finance_payment_allocations
-- ----------------------------
ALTER TABLE "public"."finance_payment_allocations" ADD CONSTRAINT "alloc_payment_fkey" FOREIGN KEY ("payment_id") REFERENCES "public"."finance_payments_out" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table finance_payments_out
-- ----------------------------
ALTER TABLE "public"."finance_payments_out" ADD CONSTRAINT "finance_payments_out_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."finance_payments_out" ADD CONSTRAINT "finance_payments_out_ref_outlet_id_fkey" FOREIGN KEY ("ref_outlet_id") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."finance_payments_out" ADD CONSTRAINT "payments_out_account_fkey" FOREIGN KEY ("financial_account_id") REFERENCES "public"."master_financial_accounts" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."finance_payments_out" ADD CONSTRAINT "payments_out_supplier_fkey" FOREIGN KEY ("kode_supplier") REFERENCES "public"."master_supplier" ("kode_supplier") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table goods_receipt_items
-- ----------------------------
ALTER TABLE "public"."goods_receipt_items" ADD CONSTRAINT "gr_items_barang_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."goods_receipt_items" ADD CONSTRAINT "gr_items_po_item_fkey" FOREIGN KEY ("po_item_id") REFERENCES "public"."purchase_order_items" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."goods_receipt_items" ADD CONSTRAINT "gr_items_receipt_fkey" FOREIGN KEY ("receipt_id") REFERENCES "public"."goods_receipts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table goods_receipts
-- ----------------------------
ALTER TABLE "public"."goods_receipts" ADD CONSTRAINT "goods_receipts_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."goods_receipts" ADD CONSTRAINT "goods_receipts_po_fkey" FOREIGN KEY ("po_id") REFERENCES "public"."purchase_orders" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."goods_receipts" ADD CONSTRAINT "goods_receipts_received_by_fkey" FOREIGN KEY ("received_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table inventory_balance
-- ----------------------------
ALTER TABLE "public"."inventory_balance" ADD CONSTRAINT "inventory_balance_barang_id_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."inventory_balance" ADD CONSTRAINT "inventory_balance_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table inventory_shrinkage_logs
-- ----------------------------
ALTER TABLE "public"."inventory_shrinkage_logs" ADD CONSTRAINT "inventory_shrinkage_logs_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."inventory_shrinkage_logs" ADD CONSTRAINT "shrink_barang_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."inventory_shrinkage_logs" ADD CONSTRAINT "shrink_cat_fkey" FOREIGN KEY ("shrinkage_category_id") REFERENCES "public"."master_shrinkage_categories" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."inventory_shrinkage_logs" ADD CONSTRAINT "shrink_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table master_barang
-- ----------------------------
ALTER TABLE "public"."master_barang" ADD CONSTRAINT "master_barang_id_type_fkey" FOREIGN KEY ("id_type") REFERENCES "public"."master_type" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."master_barang" ADD CONSTRAINT "master_barang_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table master_financial_accounts
-- ----------------------------
ALTER TABLE "public"."master_financial_accounts" ADD CONSTRAINT "financial_accounts_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table master_outlet
-- ----------------------------
ALTER TABLE "public"."master_outlet" ADD CONSTRAINT "master_outlet_outlet_group_id_fkey" FOREIGN KEY ("outlet_group_id") REFERENCES "public"."group_outlet" ("group_id") ON DELETE SET NULL ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table master_recipe_items
-- ----------------------------
ALTER TABLE "public"."master_recipe_items" ADD CONSTRAINT "items_material_fkey" FOREIGN KEY ("material_barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."master_recipe_items" ADD CONSTRAINT "items_recipe_fkey" FOREIGN KEY ("recipe_id") REFERENCES "public"."master_recipes" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table master_recipes
-- ----------------------------
ALTER TABLE "public"."master_recipes" ADD CONSTRAINT "recipe_barang_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."master_recipes" ADD CONSTRAINT "recipe_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table master_supplier
-- ----------------------------
ALTER TABLE "public"."master_supplier" ADD CONSTRAINT "master_supplier_kode_bank_fkey" FOREIGN KEY ("kode_bank") REFERENCES "public"."master_bank" ("kode_bank") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."master_supplier" ADD CONSTRAINT "master_supplier_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table production_run_ingredients
-- ----------------------------
ALTER TABLE "public"."production_run_ingredients" ADD CONSTRAINT "prod_ing_barang_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."production_run_ingredients" ADD CONSTRAINT "prod_ing_run_fkey" FOREIGN KEY ("run_id") REFERENCES "public"."production_runs" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table production_run_outputs
-- ----------------------------
ALTER TABLE "public"."production_run_outputs" ADD CONSTRAINT "prod_out_barang_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."production_run_outputs" ADD CONSTRAINT "prod_out_run_fkey" FOREIGN KEY ("run_id") REFERENCES "public"."production_runs" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table production_runs
-- ----------------------------
ALTER TABLE "public"."production_runs" ADD CONSTRAINT "production_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."production_runs" ADD CONSTRAINT "production_runs_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table profiles
-- ----------------------------
ALTER TABLE "public"."profiles" ADD CONSTRAINT "profiles_location_id_fkey" FOREIGN KEY ("location_id") REFERENCES "public"."locations" ("id") ON DELETE SET NULL ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table purchase_invoices
-- ----------------------------
ALTER TABLE "public"."purchase_invoices" ADD CONSTRAINT "fk_purchase_invoices_po" FOREIGN KEY ("purchase_order_id") REFERENCES "public"."purchase_orders" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table purchase_order_items
-- ----------------------------
ALTER TABLE "public"."purchase_order_items" ADD CONSTRAINT "purchase_order_items_barang_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."purchase_order_items" ADD CONSTRAINT "purchase_order_items_po_fkey" FOREIGN KEY ("po_id") REFERENCES "public"."purchase_orders" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table purchase_orders
-- ----------------------------
ALTER TABLE "public"."purchase_orders" ADD CONSTRAINT "purchase_orders_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."purchase_orders" ADD CONSTRAINT "purchase_orders_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."purchase_orders" ADD CONSTRAINT "purchase_orders_supplier_fkey" FOREIGN KEY ("kode_supplier") REFERENCES "public"."master_supplier" ("kode_supplier") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table sto_invoices
-- ----------------------------
ALTER TABLE "public"."sto_invoices" ADD CONSTRAINT "sto_invoices_owe_to_outlet_id_fkey" FOREIGN KEY ("owe_to_outlet_id") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_invoices" ADD CONSTRAINT "sto_invoices_sto_id_fkey" FOREIGN KEY ("sto_id") REFERENCES "public"."sto_orders" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table sto_items
-- ----------------------------
ALTER TABLE "public"."sto_items" ADD CONSTRAINT "sto_items_barang_id_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_items" ADD CONSTRAINT "sto_items_sto_id_fkey" FOREIGN KEY ("sto_id") REFERENCES "public"."sto_orders" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table sto_orders
-- ----------------------------
ALTER TABLE "public"."sto_orders" ADD CONSTRAINT "sto_orders_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_orders" ADD CONSTRAINT "sto_orders_from_outlet_fkey" FOREIGN KEY ("from_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_orders" ADD CONSTRAINT "sto_orders_to_outlet_fkey" FOREIGN KEY ("to_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table sto_receipt_items
-- ----------------------------
ALTER TABLE "public"."sto_receipt_items" ADD CONSTRAINT "sto_receipt_items_barang_id_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_receipt_items" ADD CONSTRAINT "sto_receipt_items_receipt_id_fkey" FOREIGN KEY ("receipt_id") REFERENCES "public"."sto_receipts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_receipt_items" ADD CONSTRAINT "sto_receipt_items_sto_item_id_fkey" FOREIGN KEY ("sto_item_id") REFERENCES "public"."sto_items" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table sto_receipts
-- ----------------------------
ALTER TABLE "public"."sto_receipts" ADD CONSTRAINT "sto_receipts_received_by_fkey" FOREIGN KEY ("received_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_receipts" ADD CONSTRAINT "sto_receipts_sto_id_fkey" FOREIGN KEY ("sto_id") REFERENCES "public"."sto_orders" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table sto_shipment_items
-- ----------------------------
ALTER TABLE "public"."sto_shipment_items" ADD CONSTRAINT "sto_shipment_items_barang_id_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_shipment_items" ADD CONSTRAINT "sto_shipment_items_shipment_id_fkey" FOREIGN KEY ("shipment_id") REFERENCES "public"."sto_shipments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_shipment_items" ADD CONSTRAINT "sto_shipment_items_sto_item_id_fkey" FOREIGN KEY ("sto_item_id") REFERENCES "public"."sto_items" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table sto_shipments
-- ----------------------------
ALTER TABLE "public"."sto_shipments" ADD CONSTRAINT "sto_shipments_shipped_by_fkey" FOREIGN KEY ("shipped_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."sto_shipments" ADD CONSTRAINT "sto_shipments_sto_id_fkey" FOREIGN KEY ("sto_id") REFERENCES "public"."sto_orders" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table stock_opname_headers
-- ----------------------------
ALTER TABLE "public"."stock_opname_headers" ADD CONSTRAINT "so_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."stock_opname_headers" ADD CONSTRAINT "stock_opname_headers_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table stock_opname_items
-- ----------------------------
ALTER TABLE "public"."stock_opname_items" ADD CONSTRAINT "so_barang_fkey" FOREIGN KEY ("barang_id") REFERENCES "public"."master_barang" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "public"."stock_opname_items" ADD CONSTRAINT "so_header_fkey" FOREIGN KEY ("header_id") REFERENCES "public"."stock_opname_headers" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table trans_detail
-- ----------------------------
ALTER TABLE "public"."trans_detail" ADD CONSTRAINT "trans_detail_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table trans_master
-- ----------------------------
ALTER TABLE "public"."trans_master" ADD CONSTRAINT "trans_master_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table trans_payment
-- ----------------------------
ALTER TABLE "public"."trans_payment" ADD CONSTRAINT "trans_payment_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table trans_payment_detail
-- ----------------------------
ALTER TABLE "public"."trans_payment_detail" ADD CONSTRAINT "trans_payment_detail_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- ----------------------------
-- Foreign Keys structure for table users_profile
-- ----------------------------
ALTER TABLE "public"."users_profile" ADD CONSTRAINT "users_profile_kode_outlet_fkey" FOREIGN KEY ("kode_outlet") REFERENCES "public"."master_outlet" ("kode_outlet") ON DELETE SET NULL ON UPDATE NO ACTION;
ALTER TABLE "public"."users_profile" ADD CONSTRAINT "users_profile_uid_fkey" FOREIGN KEY ("uid") REFERENCES "auth"."users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "public"."users_profile" ADD CONSTRAINT "users_profile_user_role_fkey" FOREIGN KEY ("user_role") REFERENCES "public"."role_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
